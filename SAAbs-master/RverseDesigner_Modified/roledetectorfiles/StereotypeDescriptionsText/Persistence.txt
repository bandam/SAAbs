Provides the API for accessing and processing data stored in a data source (usually a relational database) using the JavaTM programming language.
See: Description

Interface Summary 
Interface	Description
Array	
The mapping in the Java programming language for the SQL type ARRAY.
Blob	
The representation (mapping) in the JavaTM programming language of an SQL BLOB value.
CallableStatement	
The interface used to execute SQL stored procedures.
Clob	
The mapping in the JavaTM programming language for the SQL CLOB type.
Connection	
A connection (session) with a specific database.
DatabaseMetaData	
Comprehensive information about the database as a whole.
Driver	
The interface that every driver class must implement.
NClob	
The mapping in the JavaTM programming language for the SQL NCLOB type.
ParameterMetaData	
An object that can be used to get information about the types and properties for each parameter marker in a PreparedStatement object.
PreparedStatement	
An object that represents a precompiled SQL statement.
Ref	
The mapping in the Java programming language of an SQL REF value, which is a reference to an SQL structured type value in the database.
ResultSet	
A table of data representing a database result set, which is usually generated by executing a statement that queries the database.
ResultSetMetaData	
An object that can be used to get information about the types and properties of the columns in a ResultSet object.
RowId	
The representation (mapping) in the Java programming language of an SQL ROWID value.
Savepoint	
The representation of a savepoint, which is a point within the current transaction that can be referenced from the Connection.rollback method.
SQLData	
The interface used for the custom mapping of an SQL user-defined type (UDT) to a class in the Java programming language.
SQLInput	
An input stream that contains a stream of values representing an instance of an SQL structured type or an SQL distinct type.
SQLOutput	
The output stream for writing the attributes of a user-defined type back to the database.
SQLXML	
The mapping in the JavaTM programming language for the SQL XML type.
Statement	
The object used for executing a static SQL statement and returning the results it produces.
Struct	
The standard mapping in the Java programming language for an SQL structured type.
Wrapper	
Interface for JDBC classes which provide the ability to retrieve the delegate instance when the instance in question is in fact a proxy class.
Class Summary 
Class	Description
Date	
A thin wrapper around a millisecond value that allows JDBC to identify this as an SQL DATE value.
DriverManager	
The basic service for managing a set of JDBC drivers.
NOTE: The DataSource interface, new in the JDBC 2.0 API, provides another way to connect to a data source.
DriverPropertyInfo	
Driver properties for making a connection.
SQLPermission	
The permission for which the SecurityManager will check when code that is running in an applet, or an application with a SecurityManager enabled, calls the DriverManager.setLogWriter method, DriverManager.setLogStream (deprecated) method, SyncFactory.setJNDIContext method, SyncFactory.setLogger method, Connection.setNetworktimeout method, or the Connection.abort method.
Time	
A thin wrapper around the java.util.Date class that allows the JDBC API to identify this as an SQL TIME value.
Timestamp	
A thin wrapper around java.util.Date that allows the JDBC API to identify this as an SQL TIMESTAMP value.
Types	
The class that defines the constants that are used to identify generic SQL types, called JDBC types.
Enum Summary 
Enum	Description
ClientInfoStatus	
Enumeration for status of the reason that a property could not be set via a call to Connection.setClientInfo
PseudoColumnUsage	
Enumeration for pseudo/hidden column usage.
RowIdLifetime	
Enumeration for RowId life-time values.
Exception Summary 
Exception	Description
BatchUpdateException	
The subclass of SQLException thrown when an error occurs during a batch update operation.
DataTruncation	
An exception thrown as a DataTruncation exception (on writes) or reported as a DataTruncation warning (on reads) when a data values is unexpectedly truncated for reasons other than its having execeeded MaxFieldSize.
SQLClientInfoException	
The subclass of SQLException is thrown when one or more client info properties could not be set on a Connection.
SQLDataException	
The subclass of SQLException thrown when the SQLState class value is '22', or under vendor-specified conditions.
SQLException	
An exception that provides information on a database access error or other errors.
SQLFeatureNotSupportedException	
The subclass of SQLException thrown when the SQLState class value is '0A' ( the value is 'zero' A).
SQLIntegrityConstraintViolationException	
The subclass of SQLException thrown when the SQLState class value is '23', or under vendor-specified conditions.
SQLInvalidAuthorizationSpecException	
The subclass of SQLException thrown when the SQLState class value is '28', or under vendor-specified conditions.
SQLNonTransientConnectionException	
The subclass of SQLException thrown for the SQLState class value '08', or under vendor-specified conditions.
SQLNonTransientException	
The subclass of SQLException thrown when an instance where a retry of the same operation would fail unless the cause of the SQLException is corrected.
SQLRecoverableException	
The subclass of SQLException thrown in situations where a previously failed operation might be able to succeed if the application performs some recovery steps and retries the entire transaction or in the case of a distributed transaction, the transaction branch.
SQLSyntaxErrorException	
The subclass of SQLException thrown when the SQLState class value is '42', or under vendor-specified conditions.
SQLTimeoutException	
The subclass of SQLException thrown when the timeout specified by Statement has expired.
SQLTransactionRollbackException	
The subclass of SQLException thrown when the SQLState class value is '40', or under vendor-specified conditions.
SQLTransientConnectionException	
The subclass of SQLException for the SQLState class value '08', or under vendor-specified conditions.
SQLTransientException	
The subclass of SQLException is thrown in situations where a previoulsy failed operation might be able to succeed when the operation is retried without any intervention by application-level functionality.
SQLWarning	
An exception that provides information on database access warnings.
Package java.sql Description

Provides the API for accessing and processing data stored in a data source (usually a relational database) using the JavaTM programming language. This API includes a framework whereby different drivers can be installed dynamically to access different data sources. Although the JDBCTM API is mainly geared to passing SQL statements to a database, it provides for reading and writing data from any data source with a tabular format. The reader/writer facility, available through the javax.sql.RowSet group of interfaces, can be customized to use and update data from a spread sheet, flat file, or any other tabular data source.
What the JDBCTM 4.1 API Includes

The JDBCTM 4.1 API includes both the java.sql package, referred to as the JDBC core API, and the javax.sql package, referred to as the JDBC Optional Package API. This complete JDBC API is included in the JavaTM Standard Edition (Java SETM), version 7. The javax.sql package extends the functionality of the JDBC API from a client-side API to a server-side API, and it is an essential part of the JavaTM Enterprise Edition (Java EETM) technology.
Versions

The JDBC 4.1 API incorporates all of the previous JDBC API versions:
The JDBC 4.0 API
The JDBC 3.0 API
The JDBC 2.1 core API
The JDBC 2.0 Optional Package API
(Note that the JDBC 2.1 core API and the JDBC 2.0 Optional Package API together are referred to as the JDBC 2.0 API.)
The JDBC 1.2 API
The JDBC 1.0 API
Classes, interfaces, methods, fields, constructors, and exceptions have the following "since" tags that indicate when they were introduced into the Java platform. When these "since" tags are used in JavadocTM comments for the JDBC API, they indicate the following:

Since 1.7 -- new in the JDBC 4.1 API and part of the Java SE platform, version 7
Since 1.6 -- new in the JDBC 4.0 API and part of the Java SE platform, version 6
Since 1.4 -- new in the JDBC 3.0 API and part of the J2SE platform, version 1.4
Since 1.2 -- new in the JDBC 2.0 API and part of the J2SE platform, version 1.2
Since 1.1 or no "since" tag -- in the original JDBC 1.0 API and part of the JDKTM, version 1.1
NOTE: Many of the new features are optional; consequently, there is some variation in drivers and the features they support. Always check your driver's documentation to see whether it supports a feature before you try to use it.

NOTE: The class SQLPermission was added in the JavaTM 2 SDK, Standard Edition, version 1.3 release. This class is used to prevent unauthorized access to the logging stream associated with the DriverManager, which may contain information such as table names, column data, and so on.

What the java.sql Package Contains

The java.sql package contains API for the following:
Making a connection with a database via the DriverManager facility
DriverManager class -- makes a connection with a driver
SQLPermission class -- provides permission when code running within a Security Manager, such as an applet, attempts to set up a logging stream through the DriverManager
Driver interface -- provides the API for registering and connecting drivers based on JDBC technology ("JDBC drivers"); generally used only by the DriverManager class
DriverPropertyInfo class -- provides properties for a JDBC driver; not used by the general user
Sending SQL statements to a database
Statement -- used to send basic SQL statements
PreparedStatement -- used to send prepared statements or basic SQL statements (derived from Statement)
CallableStatement -- used to call database stored procedures (derived from PreparedStatement)
Connection interface -- provides methods for creating statements and managing connections and their properties
Savepoint -- provides savepoints in a transaction
Retrieving and updating the results of a query
ResultSet interface
Standard mappings for SQL types to classes and interfaces in the Java programming language
Array interface -- mapping for SQL ARRAY
Blob interface -- mapping for SQL BLOB
Clob interface -- mapping for SQL CLOB
Date class -- mapping for SQL DATE
NClob interface -- mapping for SQL NCLOB
Ref interface -- mapping for SQL REF
RowId interface -- mapping for SQL ROWID
Struct interface -- mapping for SQL STRUCT
SQLXML interface -- mapping for SQL XML
Time class -- mapping for SQL TIME
Timestamp class -- mapping for SQL TIMESTAMP
Types class -- provides constants for SQL types
Custom mapping an SQL user-defined type (UDT) to a class in the Java programming language
SQLData interface -- specifies the mapping of a UDT to an instance of this class
SQLInput interface -- provides methods for reading UDT attributes from a stream
SQLOutput interface -- provides methods for writing UDT attributes back to a stream
Metadata
DatabaseMetaData interface -- provides information about the database
ResultSetMetaData interface -- provides information about the columns of a ResultSet object
ParameterMetaData interface -- provides information about the parameters to PreparedStatement commands
Exceptions
SQLException -- thrown by most methods when there is a problem accessing data and by some methods for other reasons
SQLWarning -- thrown to indicate a warning
DataTruncation -- thrown to indicate that data may have been truncated
BatchUpdateException -- thrown to indicate that not all commands in a batch update executed successfully
java.sql and javax.sql Features Introduced in the JDBC 4.1 API

Allow Connection, ResultSet and Statement objects to be used with the try-with-resources statement
Supported added to CallableStatement and ResultSet to specify the Java type to convert to via the getObject method
DatabaseMetaData methods to return PseudoColumns and if a generated key is always returned
Added support to Connection to specify a database schema, abort and timeout a physical connection.
Added support to close a Statement object when its dependent objects have been closed
Support for obtaining the parent logger for a Driver, DataSource, ConnectionPoolDataSource and XADataSource
java.sql and javax.sql Features Introduced in the JDBC 4.0 API

auto java.sql.Driver discovery -- no longer need to load a java.sql.Driver class via Class.forName
National Character Set support added
Support added for the SQL:2003 XML data type
SQLException enhancements -- Added support for cause chaining; New SQLExceptions added for common SQLState class value codes
Enhanced Blob/Clob functionality -- Support provided to create and free a Blob/Clob instance as well as additional methods added to improve accessiblity
Support added for accessing a SQL ROWID
Support added to allow a JDBC application to access an instance of a JDBC resource that has been wrapped by a vendor, usually in an application server or connection pooling environment.
Availability to be notified when a PreparedStatement that is associated with a PooledConnection has been closed or the driver determines is invalid
java.sql and javax.sql Features Introduced in the JDBC 3.0 API

Pooled statements -- reuse of statements associated with a pooled connection
Savepoints -- allow a transaction to be rolled back to a designated savepoint
Properties defined for ConnectionPoolDataSource -- specify how connections are to be pooled
Metadata for parameters of a PreparedStatement object
Ability to retrieve values from automatically generated columns
Ability to have multiple ResultSet objects returned from CallableStatement objects open at the same time
Ability to identify parameters to CallableStatement objects by name as well as by index
ResultSet holdability -- ability to specify whether cursors should be held open or closed at the end of a transaction
Ability to retrieve and update the SQL structured type instance that a Ref object references
Ability to programmatically update BLOB, CLOB, ARRAY, and REF values.
Addition of the java.sql.Types.DATALINK data type -- allows JDBC drivers access to objects stored outside a data source
Addition of metadata for retrieving SQL type hierarchies
java.sql Features Introduced in the JDBC 2.1 Core API

Scrollable result sets--using new methods in the ResultSet interface that allow the cursor to be moved to a particular row or to a position relative to its current position
Batch updates
Programmatic updates--using ResultSet updater methods
New data types--interfaces mapping the SQL3 data types
Custom mapping of user-defined types (UDTs)
Miscellaneous features, including performance hints, the use of character streams, full precision for java.math.BigDecimal values, additional security, and support for time zones in date, time, and timestamp values.
javax.sql Features Introduced in the JDBC 2.0 Optional Package API

The DataSource interface as a means of making a connection. The Java Naming and Directory InterfaceTM (JNDI) is used for registering a DataSource object with a naming service and also for retrieving it.
Pooled connections -- allowing connections to be used and reused
Distributed transactions -- allowing a transaction to span diverse DBMS servers
RowSet technology -- providing a convenient means of handling and passing data
Custom Mapping of UDTs

A user-defined type (UDT) defined in SQL can be mapped to a class in the Java programming language. An SQL structured type or an SQL DISTINCT type are the UDTs that may be custom mapped. The following three steps set up a custom mapping:
Defining the SQL structured type or DISTINCT type in SQL
Defining the class in the Java programming language to which the SQL UDT will be mapped. This class must implement the SQLData interface.
Making an entry in a Connection object's type map that contains two things:
the fully-qualified SQL name of the UDT
the Class object for the class that implements the SQLData interface
When these are in place for a UDT, calling the methods ResultSet.getObject or CallableStatement.getObject on that UDT will automatically retrieve the custom mapping for it. Also, the PreparedStatement.setObject method will automatically map the object back to its SQL type to store it in the data source.

Package Specification

Specification of the JDBC 4.0 API
Related Documentation

Getting Started--overviews of the major interfaces
Chapters on the JDBC API--from the online version of The Java Tutorial Continued
JDBCTMAPI Tutorial and Reference, Third Edition-- a complete reference and tutorial for the JDBC 3.0 API
Since:
1.1

Provides the API for server side data source access and processing from the JavaTM programming language.
See: Description

Interface Summary 
Interface	Description
CommonDataSource	
Interface that defines the methods which are common between DataSource, XADataSource and ConnectionPoolDataSource.
ConnectionEventListener	
An object that registers to be notified of events generated by a PooledConnection object.
ConnectionPoolDataSource	
A factory for PooledConnection objects.
DataSource	
A factory for connections to the physical data source that this DataSource object represents.
PooledConnection	
An object that provides hooks for connection pool management.
RowSet	
The interface that adds support to the JDBC API for the JavaBeansTM component model.
RowSetInternal	
The interface that a RowSet object implements in order to present itself to a RowSetReader or RowSetWriter object.
RowSetListener	
An interface that must be implemented by a component that wants to be notified when a significant event happens in the life of a RowSet object.
RowSetMetaData	
An object that contains information about the columns in a RowSet object.
RowSetReader	
The facility that a disconnected RowSet object calls on to populate itself with rows of data.
RowSetWriter	
An object that implements the RowSetWriter interface, called a writer.
StatementEventListener	
An object that registers to be notified of events that occur on PreparedStatements that are in the Statement pool.
XAConnection	
An object that provides support for distributed transactions.
XADataSource	
A factory for XAConnection objects that is used internally.
Class Summary 
Class	Description
ConnectionEvent	
An Event object that provides information about the source of a connection-related event.
RowSetEvent	
An Event object generated when an event occurs to a RowSet object.
StatementEvent	
A StatementEvent is sent to all StatementEventListeners which were registered with a PooledConnection.
Package javax.sql Description

Provides the API for server side data source access and processing from the JavaTM programming language. This package supplements the java.sql package and, as of the version 1.4 release, is included in the Java Platform, Standard Edition (Java SETM). It remains an essential part of the Java Platform, Enterprise Edition (Java EETM).
The javax.sql package provides for the following:

The DataSource interface as an alternative to the DriverManager for establishing a connection with a data source
Connection pooling and Statement pooling
Distributed transactions
Rowsets
Applications use the DataSource and RowSet APIs directly, but the connection pooling and distributed transaction APIs are used internally by the middle-tier infrastructure.

Using a DataSource Object to Make a Connection

The javax.sql package provides the preferred way to make a connection with a data source. The DriverManager class, the original mechanism, is still valid, and code using it will continue to run. However, the newer DataSource mechanism is preferred because it offers many advantages over the DriverManager mechanism.
These are the main advantages of using a DataSource object to make a connection:

Changes can be made to a data source's properties, which means that it is not necessary to make changes in application code when something about the data source or driver changes.
Connection and Statement pooling and distributed transactions are available through a DataSource object that is implemented to work with the middle-tier infrastructure. Connections made through the DriverManager do not have connection and statement pooling or distributed transaction capabilities.
Driver vendors provide DataSource implementations. A particular DataSource object represents a particular physical data source, and each connection the DataSource object creates is a connection to that physical data source.

A logical name for the data source is registered with a naming service that uses the Java Naming and Directory InterfaceTM (JNDI) API, usually by a system administrator or someone performing the duties of a system administrator. An application can retrieve the DataSource object it wants by doing a lookup on the logical name that has been registered for it. The application can then use the DataSource object to create a connection to the physical data source it represents.

A DataSource object can be implemented to work with the middle tier infrastructure so that the connections it produces will be pooled for reuse. An application that uses such a DataSource implementation will automatically get a connection that participates in connection pooling. A DataSource object can also be implemented to work with the middle tier infrastructure so that the connections it produces can be used for distributed transactions without any special coding.

Connection Pooling and Statement Pooling

Connections made via a DataSource object that is implemented to work with a middle tier connection pool manager will participate in connection pooling. This can improve performance dramatically because creating new connections is very expensive. Connection pooling allows a connection to be used and reused, thus cutting down substantially on the number of new connections that need to be created.
Connection pooling is totally transparent. It is done automatically in the middle tier of a Java EE configuration, so from an application's viewpoint, no change in code is required. An application simply uses the DataSource.getConnection method to get the pooled connection and uses it the same way it uses any Connection object.

The classes and interfaces used for connection pooling are:

ConnectionPoolDataSource
PooledConnection
ConnectionEvent
ConnectionEventListener
StatementEvent
StatementEventListener
The connection pool manager, a facility in the middle tier of a three-tier architecture, uses these classes and interfaces behind the scenes. When a ConnectionPoolDataSource object is called on to create a PooledConnection object, the connection pool manager will register as a ConnectionEventListener object with the new PooledConnection object. When the connection is closed or there is an error, the connection pool manager (being a listener) gets a notification that includes a ConnectionEvent object.
If the connection pool manager supports Statement pooling, for PreparedStatements, which can be determined by invoking the method DatabaseMetaData.supportsStatementPooling, the connection pool manager will register as a StatementEventListener object with the new PooledConnection object. When the PreparedStatement is closed or there is an error, the connection pool manager (being a listener) gets a notification that includes a StatementEvent object.

Distributed Transactions

As with pooled connections, connections made via a DataSource object that is implemented to work with the middle tier infrastructure may participate in distributed transactions. This gives an application the ability to involve data sources on multiple servers in a single transaction.
The classes and interfaces used for distributed transactions are:

XADataSource
XAConnection
These interfaces are used by the transaction manager; an application does not use them directly.
The XAConnection interface is derived from the PooledConnection interface, so what applies to a pooled connection also applies to a connection that is part of a distributed transaction. A transaction manager in the middle tier handles everything transparently. The only change in application code is that an application cannot do anything that would interfere with the transaction manager's handling of the transaction. Specifically, an application cannot call the methods Connection.commit or Connection.rollback, and it cannot set the connection to be in auto-commit mode (that is, it cannot call Connection.setAutoCommit(true)).

An application does not need to do anything special to participate in a distributed transaction. It simply creates connections to the data sources it wants to use via the DataSource.getConnection method, just as it normally does. The transaction manager manages the transaction behind the scenes. The XADataSource interface creates XAConnection objects, and each XAConnection object creates an XAResource object that the transaction manager uses to manage the connection.

Rowsets

The RowSet interface works with various other classes and interfaces behind the scenes. These can be grouped into three categories.
Event Notification
RowSetListener
A RowSet object is a JavaBeansTM component because it has properties and participates in the JavaBeans event notification mechanism. The RowSetListener interface is implemented by a component that wants to be notified about events that occur to a particular RowSet object. Such a component registers itself as a listener with a rowset via the RowSet.addRowSetListener method.
When the RowSet object changes one of its rows, changes all of it rows, or moves its cursor, it also notifies each listener that is registered with it. The listener reacts by carrying out its implementation of the notification method called on it.

RowSetEvent
As part of its internal notification process, a RowSet object creates an instance of RowSetEvent and passes it to the listener. The listener can use this RowSetEvent object to find out which rowset had the event.
Metadata
RowSetMetaData
This interface, derived from the ResultSetMetaData interface, provides information about the columns in a RowSet object. An application can use RowSetMetaData methods to find out how many columns the rowset contains and what kind of data each column can contain.
The RowSetMetaData interface provides methods for setting the information about columns, but an application would not normally use these methods. When an application calls the RowSet method execute, the RowSet object will contain a new set of rows, and its RowSetMetaData object will have been internally updated to contain information about the new columns.

The Reader/Writer Facility
A RowSet object that implements the RowSetInternal interface can call on the RowSetReader object associated with it to populate itself with data. It can also call on the RowSetWriter object associated with it to write any changes to its rows back to the data source from which it originally got the rows. A rowset that remains connected to its data source does not need to use a reader and writer because it can simply operate on the data source directly.
RowSetInternal
By implementing the RowSetInternal interface, a RowSet object gets access to its internal state and is able to call on its reader and writer. A rowset keeps track of the values in its current rows and of the values that immediately preceded the current ones, referred to as the original values. A rowset also keeps track of (1) the parameters that have been set for its command and (2) the connection that was passed to it, if any. A rowset uses the RowSetInternal methods behind the scenes to get access to this information. An application does not normally invoke these methods directly.
RowSetReader
A disconnected RowSet object that has implemented the RowSetInternal interface can call on its reader (the RowSetReader object associated with it) to populate it with data. When an application calls the RowSet.execute method, that method calls on the rowset's reader to do much of the work. Implementations can vary widely, but generally a reader makes a connection to the data source, reads data from the data source and populates the rowset with it, and closes the connection. A reader may also update the RowSetMetaData object for its rowset. The rowset's internal state is also updated, either by the reader or directly by the method RowSet.execute.
RowSetWriter
A disconnected RowSet object that has implemented the RowSetInternal interface can call on its writer (the RowSetWriter object associated with it) to write changes back to the underlying data source. Implementations may vary widely, but generally, a writer will do the following:
Make a connection to the data source
Check to see whether there is a conflict, that is, whether a value that has been changed in the rowset has also been changed in the data source
Write the new values to the data source if there is no conflict
Close the connection
The RowSet interface may be implemented in any number of ways, and anyone may write an implementation. Developers are encouraged to use their imaginations in coming up with new ways to use rowsets.

IMPORTANT NOTE: Code that uses API marked "Since 1.6" must be run using a JDBC technology driver that implements the JDBC 4.0 API. You must check your driver documentation to be sure that it implements the particular features you want to use.

Package Specification

Specification of the JDBC 4.0 API
Related Documentation

The Java Series book published by Addison-Wesley Longman provides detailed information about the classes and interfaces in the javax.sql package:
JDBCTM API Tutorial and Reference, Third Edition:
Since:
1.4

All Superinterfaces:
AutoCloseable, ResultSet, Wrapper
All Known Subinterfaces:
CachedRowSet, FilteredRowSet, JdbcRowSet, JoinRowSet, SyncResolver, WebRowSet

public interface RowSet
extends ResultSet
The interface that adds support to the JDBC API for the JavaBeansTM component model. A rowset, which can be used as a JavaBeans component in a visual Bean development environment, can be created and configured at design time and executed at run time.
The RowSet interface provides a set of JavaBeans properties that allow a RowSet instance to be configured to connect to a JDBC data source and read some data from the data source. A group of setter methods (setInt, setBytes, setString, and so on) provide a way to pass input parameters to a rowset's command property. This command is the SQL query the rowset uses when it gets its data from a relational database, which is generally the case.

The RowSet interface supports JavaBeans events, allowing other components in an application to be notified when an event occurs on a rowset, such as a change in its value.

The RowSet interface is unique in that it is intended to be implemented using the rest of the JDBC API. In other words, a RowSet implementation is a layer of software that executes "on top" of a JDBC driver. Implementations of the RowSet interface can be provided by anyone, including JDBC driver vendors who want to provide a RowSet implementation as part of their JDBC products.

A RowSet object may make a connection with a data source and maintain that connection throughout its life cycle, in which case it is called a connected rowset. A rowset may also make a connection with a data source, get data from it, and then close the connection. Such a rowset is called a disconnected rowset. A disconnected rowset may make changes to its data while it is disconnected and then send the changes back to the original source of the data, but it must reestablish a connection to do so.

A disconnected rowset may have a reader (a RowSetReader object) and a writer (a RowSetWriter object) associated with it. The reader may be implemented in many different ways to populate a rowset with data, including getting data from a non-relational data source. The writer can also be implemented in many different ways to propagate changes made to the rowset's data back to the underlying data source.

Rowsets are easy to use. The RowSet interface extends the standard java.sql.ResultSet interface. The RowSetMetaData interface extends the java.sql.ResultSetMetaData interface. Thus, developers familiar with the JDBC API will have to learn a minimal number of new APIs to use rowsets. In addition, third-party software tools that work with JDBC ResultSet objects will also easily be made to work with rowsets.

Since:
1.4
Field Summary

Fields inherited from interface java.sql.ResultSet
CLOSE_CURSORS_AT_COMMIT, CONCUR_READ_ONLY, CONCUR_UPDATABLE, FETCH_FORWARD, FETCH_REVERSE, FETCH_UNKNOWN, HOLD_CURSORS_OVER_COMMIT, TYPE_FORWARD_ONLY, TYPE_SCROLL_INSENSITIVE, TYPE_SCROLL_SENSITIVE
Method Summary

Methods 
Modifier and Type	Method and Description
void	addRowSetListener(RowSetListener listener)
Registers the given listener so that it will be notified of events that occur on this RowSet object.
void	clearParameters()
Clears the parameters set for this RowSet object's command.
void	execute()
Fills this RowSet object with data.
String	getCommand()
Retrieves this RowSet object's command property.
String	getDataSourceName()
Retrieves the logical name that identifies the data source for this RowSet object.
boolean	getEscapeProcessing()
Retrieves whether escape processing is enabled for this RowSet object.
int	getMaxFieldSize()
Retrieves the maximum number of bytes that may be returned for certain column values.
int	getMaxRows()
Retrieves the maximum number of rows that this RowSet object can contain.
String	getPassword()
Retrieves the password used to create a database connection.
int	getQueryTimeout()
Retrieves the maximum number of seconds the driver will wait for a statement to execute.
int	getTransactionIsolation()
Retrieves the transaction isolation level set for this RowSet object.
Map<String,Class<?>>	getTypeMap()
Retrieves the Map object associated with this RowSet object, which specifies the custom mapping of SQL user-defined types, if any.
String	getUrl()
Retrieves the url property this RowSet object will use to create a connection if it uses the DriverManager instead of a DataSource object to establish the connection.
String	getUsername()
Retrieves the username used to create a database connection for this RowSet object.
boolean	isReadOnly()
Retrieves whether this RowSet object is read-only.
void	removeRowSetListener(RowSetListener listener)
Removes the specified listener from the list of components that will be notified when an event occurs on this RowSet object.
void	setArray(int i, Array x)
Sets the designated parameter in this RowSet object's command with the given Array value.
void	setAsciiStream(int parameterIndex, InputStream x)
Sets the designated parameter in this RowSet object's command to the given input stream.
void	setAsciiStream(int parameterIndex, InputStream x, int length)
Sets the designated parameter in this RowSet object's command to the given java.io.InputStream value.
void	setAsciiStream(String parameterName, InputStream x)
Sets the designated parameter to the given input stream.
void	setAsciiStream(String parameterName, InputStream x, int length)
Sets the designated parameter to the given input stream, which will have the specified number of bytes.
void	setBigDecimal(int parameterIndex, BigDecimal x)
Sets the designated parameter in this RowSet object's command to the given java.math.BigDeciaml value.
void	setBigDecimal(String parameterName, BigDecimal x)
Sets the designated parameter to the given java.math.BigDecimal value.
void	setBinaryStream(int parameterIndex, InputStream x)
Sets the designated parameter in this RowSet object's command to the given input stream.
void	setBinaryStream(int parameterIndex, InputStream x, int length)
Sets the designated parameter in this RowSet object's command to the given java.io.InputStream value.
void	setBinaryStream(String parameterName, InputStream x)
Sets the designated parameter to the given input stream.
void	setBinaryStream(String parameterName, InputStream x, int length)
Sets the designated parameter to the given input stream, which will have the specified number of bytes.
void	setBlob(int i, Blob x)
Sets the designated parameter in this RowSet object's command with the given Blob value.
void	setBlob(int parameterIndex, InputStream inputStream)
Sets the designated parameter to a InputStream object.
void	setBlob(int parameterIndex, InputStream inputStream, long length)
Sets the designated parameter to a InputStream object.
void	setBlob(String parameterName, Blob x)
Sets the designated parameter to the given java.sql.Blob object.
void	setBlob(String parameterName, InputStream inputStream)
Sets the designated parameter to a InputStream object.
void	setBlob(String parameterName, InputStream inputStream, long length)
Sets the designated parameter to a InputStream object.
void	setBoolean(int parameterIndex, boolean x)
Sets the designated parameter in this RowSet object's command to the given Java boolean value.
void	setBoolean(String parameterName, boolean x)
Sets the designated parameter to the given Java boolean value.
void	setByte(int parameterIndex, byte x)
Sets the designated parameter in this RowSet object's command to the given Java byte value.
void	setByte(String parameterName, byte x)
Sets the designated parameter to the given Java byte value.
void	setBytes(int parameterIndex, byte[] x)
Sets the designated parameter in this RowSet object's command to the given Java array of byte values.
void	setBytes(String parameterName, byte[] x)
Sets the designated parameter to the given Java array of bytes.
void	setCharacterStream(int parameterIndex, Reader reader)
Sets the designated parameter in this RowSet object's command to the given Reader object.
void	setCharacterStream(int parameterIndex, Reader reader, int length)
Sets the designated parameter in this RowSet object's command to the given java.io.Reader value.
void	setCharacterStream(String parameterName, Reader reader)
Sets the designated parameter to the given Reader object.
void	setCharacterStream(String parameterName, Reader reader, int length)
Sets the designated parameter to the given Reader object, which is the given number of characters long.
void	setClob(int i, Clob x)
Sets the designated parameter in this RowSet object's command with the given Clob value.
void	setClob(int parameterIndex, Reader reader)
Sets the designated parameter to a Reader object.
void	setClob(int parameterIndex, Reader reader, long length)
Sets the designated parameter to a Reader object.
void	setClob(String parameterName, Clob x)
Sets the designated parameter to the given java.sql.Clob object.
void	setClob(String parameterName, Reader reader)
Sets the designated parameter to a Reader object.
void	setClob(String parameterName, Reader reader, long length)
Sets the designated parameter to a Reader object.
void	setCommand(String cmd)
Sets this RowSet object's command property to the given SQL query.
void	setConcurrency(int concurrency)
Sets the concurrency of this RowSet object to the given concurrency level.
void	setDataSourceName(String name)
Sets the data source name property for this RowSet object to the given String.
void	setDate(int parameterIndex, Date x)
Sets the designated parameter in this RowSet object's command to the given java.sql.Date value.
void	setDate(int parameterIndex, Date x, Calendar cal)
Sets the designated parameter in this RowSet object's command with the given java.sql.Date value.
void	setDate(String parameterName, Date x)
Sets the designated parameter to the given java.sql.Date value using the default time zone of the virtual machine that is running the application.
void	setDate(String parameterName, Date x, Calendar cal)
Sets the designated parameter to the given java.sql.Date value, using the given Calendar object.
void	setDouble(int parameterIndex, double x)
Sets the designated parameter in this RowSet object's command to the given Java double value.
void	setDouble(String parameterName, double x)
Sets the designated parameter to the given Java double value.
void	setEscapeProcessing(boolean enable)
Sets escape processing for this RowSet object on or off.
void	setFloat(int parameterIndex, float x)
Sets the designated parameter in this RowSet object's command to the given Java float value.
void	setFloat(String parameterName, float x)
Sets the designated parameter to the given Java float value.
void	setInt(int parameterIndex, int x)
Sets the designated parameter in this RowSet object's command to the given Java int value.
void	setInt(String parameterName, int x)
Sets the designated parameter to the given Java int value.
void	setLong(int parameterIndex, long x)
Sets the designated parameter in this RowSet object's command to the given Java long value.
void	setLong(String parameterName, long x)
Sets the designated parameter to the given Java long value.
void	setMaxFieldSize(int max)
Sets the maximum number of bytes that can be returned for a column value to the given number of bytes.
void	setMaxRows(int max)
Sets the maximum number of rows that this RowSet object can contain to the specified number.
void	setNCharacterStream(int parameterIndex, Reader value)
Sets the designated parameter in this RowSet object's command to a Reader object.
void	setNCharacterStream(int parameterIndex, Reader value, long length)
Sets the designated parameter to a Reader object.
void	setNCharacterStream(String parameterName, Reader value)
Sets the designated parameter to a Reader object.
void	setNCharacterStream(String parameterName, Reader value, long length)
Sets the designated parameter to a Reader object.
void	setNClob(int parameterIndex, NClob value)
Sets the designated parameter to a java.sql.NClob object.
void	setNClob(int parameterIndex, Reader reader)
Sets the designated parameter to a Reader object.
void	setNClob(int parameterIndex, Reader reader, long length)
Sets the designated parameter to a Reader object.
void	setNClob(String parameterName, NClob value)
Sets the designated parameter to a java.sql.NClob object.
void	setNClob(String parameterName, Reader reader)
Sets the designated parameter to a Reader object.
void	setNClob(String parameterName, Reader reader, long length)
Sets the designated parameter to a Reader object.
void	setNString(int parameterIndex, String value)
Sets the designated paramter to the given String object.
void	setNString(String parameterName, String value)
Sets the designated paramter to the given String object.
void	setNull(int parameterIndex, int sqlType)
Sets the designated parameter in this RowSet object's SQL command to SQL NULL.
void	setNull(int paramIndex, int sqlType, String typeName)
Sets the designated parameter in this RowSet object's SQL command to SQL NULL.
void	setNull(String parameterName, int sqlType)
Sets the designated parameter to SQL NULL.
void	setNull(String parameterName, int sqlType, String typeName)
Sets the designated parameter to SQL NULL.
void	setObject(int parameterIndex, Object x)
Sets the designated parameter in this RowSet object's command with a Java Object.
void	setObject(int parameterIndex, Object x, int targetSqlType)
Sets the designated parameter in this RowSet object's command with a Java Object.
void	setObject(int parameterIndex, Object x, int targetSqlType, int scaleOrLength)
Sets the designated parameter in this RowSet object's command with the given Java Object.
void	setObject(String parameterName, Object x)
Sets the value of the designated parameter with the given object.
void	setObject(String parameterName, Object x, int targetSqlType)
Sets the value of the designated parameter with the given object.
void	setObject(String parameterName, Object x, int targetSqlType, int scale)
Sets the value of the designated parameter with the given object.
void	setPassword(String password)
Sets the database password for this RowSet object to the given String.
void	setQueryTimeout(int seconds)
Sets the maximum time the driver will wait for a statement to execute to the given number of seconds.
void	setReadOnly(boolean value)
Sets whether this RowSet object is read-only to the given boolean.
void	setRef(int i, Ref x)
Sets the designated parameter in this RowSet object's command with the given Ref value.
void	setRowId(int parameterIndex, RowId x)
Sets the designated parameter to the given java.sql.RowId object.
void	setRowId(String parameterName, RowId x)
Sets the designated parameter to the given java.sql.RowId object.
void	setShort(int parameterIndex, short x)
Sets the designated parameter in this RowSet object's command to the given Java short value.
void	setShort(String parameterName, short x)
Sets the designated parameter to the given Java short value.
void	setSQLXML(int parameterIndex, SQLXML xmlObject)
Sets the designated parameter to the given java.sql.SQLXML object.
void	setSQLXML(String parameterName, SQLXML xmlObject)
Sets the designated parameter to the given java.sql.SQLXML object.
void	setString(int parameterIndex, String x)
Sets the designated parameter in this RowSet object's command to the given Java String value.
void	setString(String parameterName, String x)
Sets the designated parameter to the given Java String value.
void	setTime(int parameterIndex, Time x)
Sets the designated parameter in this RowSet object's command to the given java.sql.Time value.
void	setTime(int parameterIndex, Time x, Calendar cal)
Sets the designated parameter in this RowSet object's command with the given java.sql.Time value.
void	setTime(String parameterName, Time x)
Sets the designated parameter to the given java.sql.Time value.
void	setTime(String parameterName, Time x, Calendar cal)
Sets the designated parameter to the given java.sql.Time value, using the given Calendar object.
void	setTimestamp(int parameterIndex, Timestamp x)
Sets the designated parameter in this RowSet object's command to the given java.sql.Timestamp value.
void	setTimestamp(int parameterIndex, Timestamp x, Calendar cal)
Sets the designated parameter in this RowSet object's command with the given java.sql.Timestamp value.
void	setTimestamp(String parameterName, Timestamp x)
Sets the designated parameter to the given java.sql.Timestamp value.
void	setTimestamp(String parameterName, Timestamp x, Calendar cal)
Sets the designated parameter to the given java.sql.Timestamp value, using the given Calendar object.
void	setTransactionIsolation(int level)
Sets the transaction isolation level for this RowSet obejct.
void	setType(int type)
Sets the type of this RowSet object to the given type.
void	setTypeMap(Map<String,Class<?>> map)
Installs the given java.util.Map object as the default type map for this RowSet object.
void	setURL(int parameterIndex, URL x)
Sets the designated parameter to the given java.net.URL value.
void	setUrl(String url)
Sets the URL this RowSet object will use when it uses the DriverManager to create a connection.
void	setUsername(String name)
Sets the username property for this RowSet object to the given String.
Methods inherited from interface java.sql.ResultSet
absolute, afterLast, beforeFirst, cancelRowUpdates, clearWarnings, close, deleteRow, findColumn, first, getArray, getArray, getAsciiStream, getAsciiStream, getBigDecimal, getBigDecimal, getBigDecimal, getBigDecimal, getBinaryStream, getBinaryStream, getBlob, getBlob, getBoolean, getBoolean, getByte, getByte, getBytes, getBytes, getCharacterStream, getCharacterStream, getClob, getClob, getConcurrency, getCursorName, getDate, getDate, getDate, getDate, getDouble, getDouble, getFetchDirection, getFetchSize, getFloat, getFloat, getHoldability, getInt, getInt, getLong, getLong, getMetaData, getNCharacterStream, getNCharacterStream, getNClob, getNClob, getNString, getNString, getObject, getObject, getObject, getObject, getObject, getObject, getRef, getRef, getRow, getRowId, getRowId, getShort, getShort, getSQLXML, getSQLXML, getStatement, getString, getString, getTime, getTime, getTime, getTime, getTimestamp, getTimestamp, getTimestamp, getTimestamp, getType, getUnicodeStream, getUnicodeStream, getURL, getURL, getWarnings, insertRow, isAfterLast, isBeforeFirst, isClosed, isFirst, isLast, last, moveToCurrentRow, moveToInsertRow, next, previous, refreshRow, relative, rowDeleted, rowInserted, rowUpdated, setFetchDirection, setFetchSize, updateArray, updateArray, updateAsciiStream, updateAsciiStream, updateAsciiStream, updateAsciiStream, updateAsciiStream, updateAsciiStream, updateBigDecimal, updateBigDecimal, updateBinaryStream, updateBinaryStream, updateBinaryStream, updateBinaryStream, updateBinaryStream, updateBinaryStream, updateBlob, updateBlob, updateBlob, updateBlob, updateBlob, updateBlob, updateBoolean, updateBoolean, updateByte, updateByte, updateBytes, updateBytes, updateCharacterStream, updateCharacterStream, updateCharacterStream, updateCharacterStream, updateCharacterStream, updateCharacterStream, updateClob, updateClob, updateClob, updateClob, updateClob, updateClob, updateDate, updateDate, updateDouble, updateDouble, updateFloat, updateFloat, updateInt, updateInt, updateLong, updateLong, updateNCharacterStream, updateNCharacterStream, updateNCharacterStream, updateNCharacterStream, updateNClob, updateNClob, updateNClob, updateNClob, updateNClob, updateNClob, updateNString, updateNString, updateNull, updateNull, updateObject, updateObject, updateObject, updateObject, updateRef, updateRef, updateRow, updateRowId, updateRowId, updateShort, updateShort, updateSQLXML, updateSQLXML, updateString, updateString, updateTime, updateTime, updateTimestamp, updateTimestamp, wasNull
Methods inherited from interface java.sql.Wrapper
isWrapperFor, unwrap
Method Detail

getUrl
String getUrl()
              throws SQLException
Retrieves the url property this RowSet object will use to create a connection if it uses the DriverManager instead of a DataSource object to establish the connection. The default value is null.
Returns:
a string url
Throws:
SQLException - if a database access error occurs
See Also:
setUrl(java.lang.String)
setUrl
void setUrl(String url)
            throws SQLException
Sets the URL this RowSet object will use when it uses the DriverManager to create a connection. Setting this property is optional. If a URL is used, a JDBC driver that accepts the URL must be loaded before the rowset is used to connect to a database. The rowset will use the URL internally to create a database connection when reading or writing data. Either a URL or a data source name is used to create a connection, whichever was set to non null value most recently.
Parameters:
url - a string value; may be null
Throws:
SQLException - if a database access error occurs
See Also:
getUrl()
getDataSourceName
String getDataSourceName()
Retrieves the logical name that identifies the data source for this RowSet object.
Returns:
a data source name
See Also:
setDataSourceName(java.lang.String), setUrl(java.lang.String)
setDataSourceName
void setDataSourceName(String name)
                       throws SQLException
Sets the data source name property for this RowSet object to the given String.
The value of the data source name property can be used to do a lookup of a DataSource object that has been registered with a naming service. After being retrieved, the DataSource object can be used to create a connection to the data source that it represents.

Parameters:
name - the logical name of the data source for this RowSet object; may be null
Throws:
SQLException - if a database access error occurs
See Also:
getDataSourceName()
getUsername
String getUsername()
Retrieves the username used to create a database connection for this RowSet object. The username property is set at run time before calling the method execute. It is not usually part of the serialized state of a RowSet object.
Returns:
the username property
See Also:
setUsername(java.lang.String)
setUsername
void setUsername(String name)
                 throws SQLException
Sets the username property for this RowSet object to the given String.
Parameters:
name - a user name
Throws:
SQLException - if a database access error occurs
See Also:
getUsername()
getPassword
String getPassword()
Retrieves the password used to create a database connection. The password property is set at run time before calling the method execute. It is not usually part of the serialized state of a RowSet object.
Returns:
the password for making a database connection
See Also:
setPassword(java.lang.String)
setPassword
void setPassword(String password)
                 throws SQLException
Sets the database password for this RowSet object to the given String.
Parameters:
password - the password string
Throws:
SQLException - if a database access error occurs
See Also:
getPassword()
getTransactionIsolation
int getTransactionIsolation()
Retrieves the transaction isolation level set for this RowSet object.
Returns:
the transaction isolation level; one of Connection.TRANSACTION_READ_UNCOMMITTED, Connection.TRANSACTION_READ_COMMITTED, Connection.TRANSACTION_REPEATABLE_READ, or Connection.TRANSACTION_SERIALIZABLE
See Also:
setTransactionIsolation(int)
setTransactionIsolation
void setTransactionIsolation(int level)
                             throws SQLException
Sets the transaction isolation level for this RowSet obejct.
Parameters:
level - the transaction isolation level; one of Connection.TRANSACTION_READ_UNCOMMITTED, Connection.TRANSACTION_READ_COMMITTED, Connection.TRANSACTION_REPEATABLE_READ, or Connection.TRANSACTION_SERIALIZABLE
Throws:
SQLException - if a database access error occurs
See Also:
getTransactionIsolation()
getTypeMap
Map<String,Class<?>> getTypeMap()
                                throws SQLException
Retrieves the Map object associated with this RowSet object, which specifies the custom mapping of SQL user-defined types, if any. The default is for the type map to be empty.
Returns:
a java.util.Map object containing the names of SQL user-defined types and the Java classes to which they are to be mapped
Throws:
SQLException - if a database access error occurs
See Also:
setTypeMap(java.util.Map<java.lang.String, java.lang.Class<?>>)
setTypeMap
void setTypeMap(Map<String,Class<?>> map)
                throws SQLException
Installs the given java.util.Map object as the default type map for this RowSet object. This type map will be used unless another type map is supplied as a method parameter.
Parameters:
map - a java.util.Map object containing the names of SQL user-defined types and the Java classes to which they are to be mapped
Throws:
SQLException - if a database access error occurs
See Also:
getTypeMap()
getCommand
String getCommand()
Retrieves this RowSet object's command property. The command property contains a command string, which must be an SQL query, that can be executed to fill the rowset with data. The default value is null.
Returns:
the command string; may be null
See Also:
setCommand(java.lang.String)
setCommand
void setCommand(String cmd)
                throws SQLException
Sets this RowSet object's command property to the given SQL query. This property is optional when a rowset gets its data from a data source that does not support commands, such as a spreadsheet.
Parameters:
cmd - the SQL query that will be used to get the data for this RowSet object; may be null
Throws:
SQLException - if a database access error occurs
See Also:
getCommand()
isReadOnly
boolean isReadOnly()
Retrieves whether this RowSet object is read-only. If updates are possible, the default is for a rowset to be updatable.
Attempts to update a read-only rowset will result in an SQLException being thrown.

Returns:
true if this RowSet object is read-only; false if it is updatable
See Also:
setReadOnly(boolean)
setReadOnly
void setReadOnly(boolean value)
                 throws SQLException
Sets whether this RowSet object is read-only to the given boolean.
Parameters:
value - true if read-only; false if updatable
Throws:
SQLException - if a database access error occurs
See Also:
isReadOnly()
getMaxFieldSize
int getMaxFieldSize()
                    throws SQLException
Retrieves the maximum number of bytes that may be returned for certain column values. This limit applies only to BINARY, VARBINARY, LONGVARBINARYBINARY, CHAR, VARCHAR, LONGVARCHAR, NCHAR and NVARCHAR columns. If the limit is exceeded, the excess data is silently discarded.
Returns:
the current maximum column size limit; zero means that there is no limit
Throws:
SQLException - if a database access error occurs
See Also:
setMaxFieldSize(int)
setMaxFieldSize
void setMaxFieldSize(int max)
                     throws SQLException
Sets the maximum number of bytes that can be returned for a column value to the given number of bytes. This limit applies only to BINARY, VARBINARY, LONGVARBINARYBINARY, CHAR, VARCHAR, LONGVARCHAR, NCHAR and NVARCHAR columns. If the limit is exceeded, the excess data is silently discarded. For maximum portability, use values greater than 256.
Parameters:
max - the new max column size limit in bytes; zero means unlimited
Throws:
SQLException - if a database access error occurs
See Also:
getMaxFieldSize()
getMaxRows
int getMaxRows()
               throws SQLException
Retrieves the maximum number of rows that this RowSet object can contain. If the limit is exceeded, the excess rows are silently dropped.
Returns:
the current maximum number of rows that this RowSet object can contain; zero means unlimited
Throws:
SQLException - if a database access error occurs
See Also:
setMaxRows(int)
setMaxRows
void setMaxRows(int max)
                throws SQLException
Sets the maximum number of rows that this RowSet object can contain to the specified number. If the limit is exceeded, the excess rows are silently dropped.
Parameters:
max - the new maximum number of rows; zero means unlimited
Throws:
SQLException - if a database access error occurs
See Also:
getMaxRows()
getEscapeProcessing
boolean getEscapeProcessing()
                            throws SQLException
Retrieves whether escape processing is enabled for this RowSet object. If escape scanning is enabled, which is the default, the driver will do escape substitution before sending an SQL statement to the database.
Returns:
true if escape processing is enabled; false if it is disabled
Throws:
SQLException - if a database access error occurs
See Also:
setEscapeProcessing(boolean)
setEscapeProcessing
void setEscapeProcessing(boolean enable)
                         throws SQLException
Sets escape processing for this RowSet object on or off. If escape scanning is on (the default), the driver will do escape substitution before sending an SQL statement to the database.
Parameters:
enable - true to enable escape processing; false to disable it
Throws:
SQLException - if a database access error occurs
See Also:
getEscapeProcessing()
getQueryTimeout
int getQueryTimeout()
                    throws SQLException
Retrieves the maximum number of seconds the driver will wait for a statement to execute. If this limit is exceeded, an SQLException is thrown.
Returns:
the current query timeout limit in seconds; zero means unlimited
Throws:
SQLException - if a database access error occurs
See Also:
setQueryTimeout(int)
setQueryTimeout
void setQueryTimeout(int seconds)
                     throws SQLException
Sets the maximum time the driver will wait for a statement to execute to the given number of seconds. If this limit is exceeded, an SQLException is thrown.
Parameters:
seconds - the new query timeout limit in seconds; zero means that there is no limit
Throws:
SQLException - if a database access error occurs
See Also:
getQueryTimeout()
setType
void setType(int type)
             throws SQLException
Sets the type of this RowSet object to the given type. This method is used to change the type of a rowset, which is by default read-only and non-scrollable.
Parameters:
type - one of the ResultSet constants specifying a type: ResultSet.TYPE_FORWARD_ONLY, ResultSet.TYPE_SCROLL_INSENSITIVE, or ResultSet.TYPE_SCROLL_SENSITIVE
Throws:
SQLException - if a database access error occurs
See Also:
ResultSet.getType()
setConcurrency
void setConcurrency(int concurrency)
                    throws SQLException
Sets the concurrency of this RowSet object to the given concurrency level. This method is used to change the concurrency level of a rowset, which is by default ResultSet.CONCUR_READ_ONLY
Parameters:
concurrency - one of the ResultSet constants specifying a concurrency level: ResultSet.CONCUR_READ_ONLY or ResultSet.CONCUR_UPDATABLE
Throws:
SQLException - if a database access error occurs
See Also:
ResultSet.getConcurrency()
setNull
void setNull(int parameterIndex,
           int sqlType)
             throws SQLException
Sets the designated parameter in this RowSet object's SQL command to SQL NULL.
Note: You must specify the parameter's SQL type.

Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
sqlType - a SQL type code defined by java.sql.Types
Throws:
SQLException - if a database access error occurs
setNull
void setNull(String parameterName,
           int sqlType)
             throws SQLException
Sets the designated parameter to SQL NULL.
Note: You must specify the parameter's SQL type.

Parameters:
parameterName - the name of the parameter
sqlType - the SQL type code defined in java.sql.Types
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
setNull
void setNull(int paramIndex,
           int sqlType,
           String typeName)
             throws SQLException
Sets the designated parameter in this RowSet object's SQL command to SQL NULL. This version of the method setNull should be used for SQL user-defined types (UDTs) and REF type parameters. Examples of UDTs include: STRUCT, DISTINCT, JAVA_OBJECT, and named array types.
Note: To be portable, applications must give the SQL type code and the fully qualified SQL type name when specifying a NULL UDT or REF parameter. In the case of a UDT, the name is the type name of the parameter itself. For a REF parameter, the name is the type name of the referenced type. If a JDBC driver does not need the type code or type name information, it may ignore it. Although it is intended for UDT and REF parameters, this method may be used to set a null parameter of any JDBC type. If the parameter does not have a user-defined or REF type, the typeName parameter is ignored.

Parameters:
paramIndex - the first parameter is 1, the second is 2, ...
sqlType - a value from java.sql.Types
typeName - the fully qualified name of an SQL UDT or the type name of the SQL structured type being referenced by a REF type; ignored if the parameter is not a UDT or REF type
Throws:
SQLException - if a database access error occurs
setNull
void setNull(String parameterName,
           int sqlType,
           String typeName)
             throws SQLException
Sets the designated parameter to SQL NULL. This version of the method setNull should be used for user-defined types and REF type parameters. Examples of user-defined types include: STRUCT, DISTINCT, JAVA_OBJECT, and named array types.
Note: To be portable, applications must give the SQL type code and the fully-qualified SQL type name when specifying a NULL user-defined or REF parameter. In the case of a user-defined type the name is the type name of the parameter itself. For a REF parameter, the name is the type name of the referenced type. If a JDBC driver does not need the type code or type name information, it may ignore it. Although it is intended for user-defined and Ref parameters, this method may be used to set a null parameter of any JDBC type. If the parameter does not have a user-defined or REF type, the given typeName is ignored.

Parameters:
parameterName - the name of the parameter
sqlType - a value from java.sql.Types
typeName - the fully-qualified name of an SQL user-defined type; ignored if the parameter is not a user-defined type or SQL REF value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
setBoolean
void setBoolean(int parameterIndex,
              boolean x)
                throws SQLException
Sets the designated parameter in this RowSet object's command to the given Java boolean value. The driver converts this to an SQL BIT value before sending it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setBoolean
void setBoolean(String parameterName,
              boolean x)
                throws SQLException
Sets the designated parameter to the given Java boolean value. The driver converts this to an SQL BIT or BOOLEAN value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getBoolean(int)
setByte
void setByte(int parameterIndex,
           byte x)
             throws SQLException
Sets the designated parameter in this RowSet object's command to the given Java byte value. The driver converts this to an SQL TINYINT value before sending it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setByte
void setByte(String parameterName,
           byte x)
             throws SQLException
Sets the designated parameter to the given Java byte value. The driver converts this to an SQL TINYINT value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getByte(int)
setShort
void setShort(int parameterIndex,
            short x)
              throws SQLException
Sets the designated parameter in this RowSet object's command to the given Java short value. The driver converts this to an SQL SMALLINT value before sending it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setShort
void setShort(String parameterName,
            short x)
              throws SQLException
Sets the designated parameter to the given Java short value. The driver converts this to an SQL SMALLINT value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getShort(int)
setInt
void setInt(int parameterIndex,
          int x)
            throws SQLException
Sets the designated parameter in this RowSet object's command to the given Java int value. The driver converts this to an SQL INTEGER value before sending it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setInt
void setInt(String parameterName,
          int x)
            throws SQLException
Sets the designated parameter to the given Java int value. The driver converts this to an SQL INTEGER value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getInt(int)
setLong
void setLong(int parameterIndex,
           long x)
             throws SQLException
Sets the designated parameter in this RowSet object's command to the given Java long value. The driver converts this to an SQL BIGINT value before sending it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setLong
void setLong(String parameterName,
           long x)
             throws SQLException
Sets the designated parameter to the given Java long value. The driver converts this to an SQL BIGINT value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getLong(int)
setFloat
void setFloat(int parameterIndex,
            float x)
              throws SQLException
Sets the designated parameter in this RowSet object's command to the given Java float value. The driver converts this to an SQL REAL value before sending it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setFloat
void setFloat(String parameterName,
            float x)
              throws SQLException
Sets the designated parameter to the given Java float value. The driver converts this to an SQL FLOAT value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getFloat(int)
setDouble
void setDouble(int parameterIndex,
             double x)
               throws SQLException
Sets the designated parameter in this RowSet object's command to the given Java double value. The driver converts this to an SQL DOUBLE value before sending it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setDouble
void setDouble(String parameterName,
             double x)
               throws SQLException
Sets the designated parameter to the given Java double value. The driver converts this to an SQL DOUBLE value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getDouble(int)
setBigDecimal
void setBigDecimal(int parameterIndex,
                 BigDecimal x)
                   throws SQLException
Sets the designated parameter in this RowSet object's command to the given java.math.BigDeciaml value. The driver converts this to an SQL NUMERIC value before sending it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setBigDecimal
void setBigDecimal(String parameterName,
                 BigDecimal x)
                   throws SQLException
Sets the designated parameter to the given java.math.BigDecimal value. The driver converts this to an SQL NUMERIC value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getBigDecimal(int, int)
setString
void setString(int parameterIndex,
             String x)
               throws SQLException
Sets the designated parameter in this RowSet object's command to the given Java String value. Before sending it to the database, the driver converts this to an SQL VARCHAR or LONGVARCHAR value, depending on the argument's size relative to the driver's limits on VARCHAR values.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setString
void setString(String parameterName,
             String x)
               throws SQLException
Sets the designated parameter to the given Java String value. The driver converts this to an SQL VARCHAR or LONGVARCHAR value (depending on the argument's size relative to the driver's limits on VARCHAR values) when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getString(int)
setBytes
void setBytes(int parameterIndex,
            byte[] x)
              throws SQLException
Sets the designated parameter in this RowSet object's command to the given Java array of byte values. Before sending it to the database, the driver converts this to an SQL VARBINARY or LONGVARBINARY value, depending on the argument's size relative to the driver's limits on VARBINARY values.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setBytes
void setBytes(String parameterName,
            byte[] x)
              throws SQLException
Sets the designated parameter to the given Java array of bytes. The driver converts this to an SQL VARBINARY or LONGVARBINARY (depending on the argument's size relative to the driver's limits on VARBINARY values) when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getBytes(int)
setDate
void setDate(int parameterIndex,
           Date x)
             throws SQLException
Sets the designated parameter in this RowSet object's command to the given java.sql.Date value. The driver converts this to an SQL DATE value before sending it to the database, using the default java.util.Calendar to calculate the date.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setTime
void setTime(int parameterIndex,
           Time x)
             throws SQLException
Sets the designated parameter in this RowSet object's command to the given java.sql.Time value. The driver converts this to an SQL TIME value before sending it to the database, using the default java.util.Calendar to calculate it.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setTimestamp
void setTimestamp(int parameterIndex,
                Timestamp x)
                  throws SQLException
Sets the designated parameter in this RowSet object's command to the given java.sql.Timestamp value. The driver converts this to an SQL TIMESTAMP value before sending it to the database, using the default java.util.Calendar to calculate it.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
setTimestamp
void setTimestamp(String parameterName,
                Timestamp x)
                  throws SQLException
Sets the designated parameter to the given java.sql.Timestamp value. The driver converts this to an SQL TIMESTAMP value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getTimestamp(int)
setAsciiStream
void setAsciiStream(int parameterIndex,
                  InputStream x,
                  int length)
                    throws SQLException
Sets the designated parameter in this RowSet object's command to the given java.io.InputStream value. It may be more practical to send a very large ASCII value via a java.io.InputStream rather than as a LONGVARCHAR parameter. The driver will read the data from the stream as needed until it reaches end-of-file.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the Java input stream that contains the ASCII parameter value
length - the number of bytes in the stream
Throws:
SQLException - if a database access error occurs
setAsciiStream
void setAsciiStream(String parameterName,
                  InputStream x,
                  int length)
                    throws SQLException
Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a very large ASCII value is input to a LONGVARCHAR parameter, it may be more practical to send it via a java.io.InputStream. Data will be read from the stream as needed until end-of-file is reached. The JDBC driver will do any necessary conversion from ASCII to the database char format.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Parameters:
parameterName - the name of the parameter
x - the Java input stream that contains the ASCII parameter value
length - the number of bytes in the stream
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
setBinaryStream
void setBinaryStream(int parameterIndex,
                   InputStream x,
                   int length)
                     throws SQLException
Sets the designated parameter in this RowSet object's command to the given java.io.InputStream value. It may be more practical to send a very large binary value via a java.io.InputStream rather than as a LONGVARBINARY parameter. The driver will read the data from the stream as needed until it reaches end-of-file.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the java input stream which contains the binary parameter value
length - the number of bytes in the stream
Throws:
SQLException - if a database access error occurs
setBinaryStream
void setBinaryStream(String parameterName,
                   InputStream x,
                   int length)
                     throws SQLException
Sets the designated parameter to the given input stream, which will have the specified number of bytes. When a very large binary value is input to a LONGVARBINARY parameter, it may be more practical to send it via a java.io.InputStream object. The data will be read from the stream as needed until end-of-file is reached.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Parameters:
parameterName - the name of the parameter
x - the java input stream which contains the binary parameter value
length - the number of bytes in the stream
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
setCharacterStream
void setCharacterStream(int parameterIndex,
                      Reader reader,
                      int length)
                        throws SQLException
Sets the designated parameter in this RowSet object's command to the given java.io.Reader value. It may be more practical to send a very large UNICODE value via a java.io.Reader rather than as a LONGVARCHAR parameter. The driver will read the data from the stream as needed until it reaches end-of-file.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
reader - the Reader object that contains the UNICODE data to be set
length - the number of characters in the stream
Throws:
SQLException - if a database access error occurs
setCharacterStream
void setCharacterStream(String parameterName,
                      Reader reader,
                      int length)
                        throws SQLException
Sets the designated parameter to the given Reader object, which is the given number of characters long. When a very large UNICODE value is input to a LONGVARCHAR parameter, it may be more practical to send it via a java.io.Reader object. The data will be read from the stream as needed until end-of-file is reached. The JDBC driver will do any necessary conversion from UNICODE to the database char format.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Parameters:
parameterName - the name of the parameter
reader - the java.io.Reader object that contains the UNICODE data used as the designated parameter
length - the number of characters in the stream
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
setAsciiStream
void setAsciiStream(int parameterIndex,
                  InputStream x)
                    throws SQLException
Sets the designated parameter in this RowSet object's command to the given input stream. When a very large ASCII value is input to a LONGVARCHAR parameter, it may be more practical to send it via a java.io.InputStream. Data will be read from the stream as needed until end-of-file is reached. The JDBC driver will do any necessary conversion from ASCII to the database char format.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setAsciiStream which takes a length parameter.

Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the Java input stream that contains the ASCII parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed PreparedStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setAsciiStream
void setAsciiStream(String parameterName,
                  InputStream x)
                    throws SQLException
Sets the designated parameter to the given input stream. When a very large ASCII value is input to a LONGVARCHAR parameter, it may be more practical to send it via a java.io.InputStream. Data will be read from the stream as needed until end-of-file is reached. The JDBC driver will do any necessary conversion from ASCII to the database char format.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setAsciiStream which takes a length parameter.

Parameters:
parameterName - the name of the parameter
x - the Java input stream that contains the ASCII parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setBinaryStream
void setBinaryStream(int parameterIndex,
                   InputStream x)
                     throws SQLException
Sets the designated parameter in this RowSet object's command to the given input stream. When a very large binary value is input to a LONGVARBINARY parameter, it may be more practical to send it via a java.io.InputStream object. The data will be read from the stream as needed until end-of-file is reached.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setBinaryStream which takes a length parameter.

Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the java input stream which contains the binary parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed PreparedStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setBinaryStream
void setBinaryStream(String parameterName,
                   InputStream x)
                     throws SQLException
Sets the designated parameter to the given input stream. When a very large binary value is input to a LONGVARBINARY parameter, it may be more practical to send it via a java.io.InputStream object. The data will be read from the stream as needed until end-of-file is reached.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setBinaryStream which takes a length parameter.

Parameters:
parameterName - the name of the parameter
x - the java input stream which contains the binary parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setCharacterStream
void setCharacterStream(int parameterIndex,
                      Reader reader)
                        throws SQLException
Sets the designated parameter in this RowSet object's command to the given Reader object. When a very large UNICODE value is input to a LONGVARCHAR parameter, it may be more practical to send it via a java.io.Reader object. The data will be read from the stream as needed until end-of-file is reached. The JDBC driver will do any necessary conversion from UNICODE to the database char format.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setCharacterStream which takes a length parameter.

Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
reader - the java.io.Reader object that contains the Unicode data
Throws:
SQLException - if a database access error occurs or this method is called on a closed PreparedStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setCharacterStream
void setCharacterStream(String parameterName,
                      Reader reader)
                        throws SQLException
Sets the designated parameter to the given Reader object. When a very large UNICODE value is input to a LONGVARCHAR parameter, it may be more practical to send it via a java.io.Reader object. The data will be read from the stream as needed until end-of-file is reached. The JDBC driver will do any necessary conversion from UNICODE to the database char format.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setCharacterStream which takes a length parameter.

Parameters:
parameterName - the name of the parameter
reader - the java.io.Reader object that contains the Unicode data
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setNCharacterStream
void setNCharacterStream(int parameterIndex,
                       Reader value)
                         throws SQLException
Sets the designated parameter in this RowSet object's command to a Reader object. The Reader reads the data till end-of-file is reached. The driver does the necessary conversion from Java character format to the national character set in the database.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setNCharacterStream which takes a length parameter.

Parameters:
parameterIndex - of the first parameter is 1, the second is 2, ...
value - the parameter value
Throws:
SQLException - if the driver does not support national character sets; if the driver can detect that a data conversion error could occur ; if a database access error occurs; or this method is called on a closed PreparedStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setObject
void setObject(int parameterIndex,
             Object x,
             int targetSqlType,
             int scaleOrLength)
               throws SQLException
Sets the designated parameter in this RowSet object's command with the given Java Object. For integral values, the java.lang equivalent objects should be used (for example, an instance of the class Integer for an int). If the second argument is an InputStream then the stream must contain the number of bytes specified by scaleOrLength. If the second argument is a Reader then the reader must contain the number of characters specified * by scaleOrLength. If these conditions are not true the driver will generate a SQLException when the prepared statement is executed.
The given Java object will be converted to the targetSqlType before being sent to the database.

If the object is of a class implementing SQLData, the rowset should call the method SQLData.writeSQL to write the object to an SQLOutput data stream. If, on the other hand, the object is of a class implementing Ref, Blob, Clob, NClob, Struct, java.net.URL, or Array, the driver should pass it to the database as a value of the corresponding SQL type.

Note that this method may be used to pass datatabase-specific abstract data types.

Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the object containing the input parameter value
targetSqlType - the SQL type (as defined in java.sql.Types) to be sent to the database. The scale argument may further qualify this type.
scaleOrLength - for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types, this is the number of digits after the decimal point. For Java Object types InputStream and Reader, this is the length of the data in the stream or reader. For all other types, this value will be ignored.
Throws:
SQLException - if a database access error occurs
See Also:
Types
setObject
void setObject(String parameterName,
             Object x,
             int targetSqlType,
             int scale)
               throws SQLException
Sets the value of the designated parameter with the given object. The second argument must be an object type; for integral values, the java.lang equivalent objects should be used.
The given Java object will be converted to the given targetSqlType before being sent to the database. If the object has a custom mapping (is of a class implementing the interface SQLData), the JDBC driver should call the method SQLData.writeSQL to write it to the SQL data stream. If, on the other hand, the object is of a class implementing Ref, Blob, Clob, NClob, Struct, java.net.URL, or Array, the driver should pass it to the database as a value of the corresponding SQL type.

Note that this method may be used to pass datatabase- specific abstract data types.

Parameters:
parameterName - the name of the parameter
x - the object containing the input parameter value
targetSqlType - the SQL type (as defined in java.sql.Types) to be sent to the database. The scale argument may further qualify this type.
scale - for java.sql.Types.DECIMAL or java.sql.Types.NUMERIC types, this is the number of digits after the decimal point. For all other types, this value will be ignored.
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if targetSqlType is a ARRAY, BLOB, CLOB, DATALINK, JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF, ROWID, SQLXML or STRUCT data type and the JDBC driver does not support this data type
Since:
1.4
See Also:
Types, ResultSet.getObject(int)
setObject
void setObject(int parameterIndex,
             Object x,
             int targetSqlType)
               throws SQLException
Sets the designated parameter in this RowSet object's command with a Java Object. For integral values, the java.lang equivalent objects should be used. This method is like setObject above, but the scale used is the scale of the second parameter. Scalar values have a scale of zero. Literal values have the scale present in the literal.
Even though it is supported, it is not recommended that this method be called with floating point input values.

Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the object containing the input parameter value
targetSqlType - the SQL type (as defined in java.sql.Types) to be sent to the database
Throws:
SQLException - if a database access error occurs
setObject
void setObject(String parameterName,
             Object x,
             int targetSqlType)
               throws SQLException
Sets the value of the designated parameter with the given object. This method is like the method setObject above, except that it assumes a scale of zero.
Parameters:
parameterName - the name of the parameter
x - the object containing the input parameter value
targetSqlType - the SQL type (as defined in java.sql.Types) to be sent to the database
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if targetSqlType is a ARRAY, BLOB, CLOB, DATALINK, JAVA_OBJECT, NCHAR, NCLOB, NVARCHAR, LONGNVARCHAR, REF, ROWID, SQLXML or STRUCT data type and the JDBC driver does not support this data type
Since:
1.4
See Also:
ResultSet.getObject(int)
setObject
void setObject(String parameterName,
             Object x)
               throws SQLException
Sets the value of the designated parameter with the given object. The second parameter must be of type Object; therefore, the java.lang equivalent objects should be used for built-in types.
The JDBC specification specifies a standard mapping from Java Object types to SQL types. The given argument will be converted to the corresponding SQL type before being sent to the database.

Note that this method may be used to pass datatabase- specific abstract data types, by using a driver-specific Java type. If the object is of a class implementing the interface SQLData, the JDBC driver should call the method SQLData.writeSQL to write it to the SQL data stream. If, on the other hand, the object is of a class implementing Ref, Blob, Clob, NClob, Struct, java.net.URL, or Array, the driver should pass it to the database as a value of the corresponding SQL type.

This method throws an exception if there is an ambiguity, for example, if the object is of a class implementing more than one of the interfaces named above.

Parameters:
parameterName - the name of the parameter
x - the object containing the input parameter value
Throws:
SQLException - if a database access error occurs, this method is called on a closed CallableStatement or if the given Object parameter is ambiguous
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getObject(int)
setObject
void setObject(int parameterIndex,
             Object x)
               throws SQLException
Sets the designated parameter in this RowSet object's command with a Java Object. For integral values, the java.lang equivalent objects should be used.
The JDBC specification provides a standard mapping from Java Object types to SQL types. The driver will convert the given Java object to its standard SQL mapping before sending it to the database.

Note that this method may be used to pass datatabase-specific abstract data types by using a driver-specific Java type. If the object is of a class implementing SQLData, the rowset should call the method SQLData.writeSQL to write the object to an SQLOutput data stream. If, on the other hand, the object is of a class implementing Ref, Blob, Clob, NClob, Struct, java.net.URL, or Array, the driver should pass it to the database as a value of the corresponding SQL type.

An exception is thrown if there is an ambiguity, for example, if the object is of a class implementing more than one of these interfaces.

Parameters:
parameterIndex - The first parameter is 1, the second is 2, ...
x - The object containing the input parameter value
Throws:
SQLException - if a database access error occurs
setRef
void setRef(int i,
          Ref x)
            throws SQLException
Sets the designated parameter in this RowSet object's command with the given Ref value. The driver will convert this to the appropriate REF(<structured-type>) value.
Parameters:
i - the first parameter is 1, the second is 2, ...
x - an object representing data of an SQL REF type
Throws:
SQLException - if a database access error occurs
setBlob
void setBlob(int i,
           Blob x)
             throws SQLException
Sets the designated parameter in this RowSet object's command with the given Blob value. The driver will convert this to the BLOB value that the Blob object represents before sending it to the database.
Parameters:
i - the first parameter is 1, the second is 2, ...
x - an object representing a BLOB
Throws:
SQLException - if a database access error occurs
setBlob
void setBlob(int parameterIndex,
           InputStream inputStream,
           long length)
             throws SQLException
Sets the designated parameter to a InputStream object. The inputstream must contain the number of characters specified by length otherwise a SQLException will be generated when the PreparedStatement is executed. This method differs from the setBinaryStream (int, InputStream, int) method because it informs the driver that the parameter value should be sent to the server as a BLOB. When the setBinaryStream method is used, the driver may have to do extra work to determine whether the parameter data should be sent to the server as a LONGVARBINARY or a BLOB
Parameters:
parameterIndex - index of the first parameter is 1, the second is 2, ...
inputStream - An object that contains the data to set the parameter value to.
length - the number of bytes in the parameter data.
Throws:
SQLException - if a database access error occurs, this method is called on a closed PreparedStatement, if parameterIndex does not correspond to a parameter marker in the SQL statement, if the length specified is less than zero or if the number of bytes in the inputstream does not match the specfied length.
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setBlob
void setBlob(int parameterIndex,
           InputStream inputStream)
             throws SQLException
Sets the designated parameter to a InputStream object. This method differs from the setBinaryStream (int, InputStream) method because it informs the driver that the parameter value should be sent to the server as a BLOB. When the setBinaryStream method is used, the driver may have to do extra work to determine whether the parameter data should be sent to the server as a LONGVARBINARY or a BLOB
Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setBlob which takes a length parameter.

Parameters:
parameterIndex - index of the first parameter is 1, the second is 2, ...
inputStream - An object that contains the data to set the parameter value to.
Throws:
SQLException - if a database access error occurs, this method is called on a closed PreparedStatement or if parameterIndex does not correspond to a parameter marker in the SQL statement,
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setBlob
void setBlob(String parameterName,
           InputStream inputStream,
           long length)
             throws SQLException
Sets the designated parameter to a InputStream object. The inputstream must contain the number of characters specified by length, otherwise a SQLException will be generated when the CallableStatement is executed. This method differs from the setBinaryStream (int, InputStream, int) method because it informs the driver that the parameter value should be sent to the server as a BLOB. When the setBinaryStream method is used, the driver may have to do extra work to determine whether the parameter data should be sent to the server as a LONGVARBINARY or a BLOB
Parameters:
parameterName - the name of the parameter to be set the second is 2, ...
inputStream - An object that contains the data to set the parameter value to.
length - the number of bytes in the parameter data.
Throws:
SQLException - if parameterIndex does not correspond to a parameter marker in the SQL statement, or if the length specified is less than zero; if the number of bytes in the inputstream does not match the specfied length; if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setBlob
void setBlob(String parameterName,
           Blob x)
             throws SQLException
Sets the designated parameter to the given java.sql.Blob object. The driver converts this to an SQL BLOB value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - a Blob object that maps an SQL BLOB value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setBlob
void setBlob(String parameterName,
           InputStream inputStream)
             throws SQLException
Sets the designated parameter to a InputStream object. This method differs from the setBinaryStream (int, InputStream) method because it informs the driver that the parameter value should be sent to the server as a BLOB. When the setBinaryStream method is used, the driver may have to do extra work to determine whether the parameter data should be send to the server as a LONGVARBINARY or a BLOB
Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setBlob which takes a length parameter.

Parameters:
parameterName - the name of the parameter
inputStream - An object that contains the data to set the parameter value to.
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setClob
void setClob(int i,
           Clob x)
             throws SQLException
Sets the designated parameter in this RowSet object's command with the given Clob value. The driver will convert this to the CLOB value that the Clob object represents before sending it to the database.
Parameters:
i - the first parameter is 1, the second is 2, ...
x - an object representing a CLOB
Throws:
SQLException - if a database access error occurs
setClob
void setClob(int parameterIndex,
           Reader reader,
           long length)
             throws SQLException
Sets the designated parameter to a Reader object. The reader must contain the number of characters specified by length otherwise a SQLException will be generated when the PreparedStatement is executed. This method differs from the setCharacterStream (int, Reader, int) method because it informs the driver that the parameter value should be sent to the server as a CLOB. When the setCharacterStream method is used, the driver may have to do extra work to determine whether the parameter data should be sent to the server as a LONGVARCHAR or a CLOB
Parameters:
parameterIndex - index of the first parameter is 1, the second is 2, ...
reader - An object that contains the data to set the parameter value to.
length - the number of characters in the parameter data.
Throws:
SQLException - if a database access error occurs, this method is called on a closed PreparedStatement, if parameterIndex does not correspond to a parameter marker in the SQL statement, or if the length specified is less than zero.
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setClob
void setClob(int parameterIndex,
           Reader reader)
             throws SQLException
Sets the designated parameter to a Reader object. This method differs from the setCharacterStream (int, Reader) method because it informs the driver that the parameter value should be sent to the server as a CLOB. When the setCharacterStream method is used, the driver may have to do extra work to determine whether the parameter data should be sent to the server as a LONGVARCHAR or a CLOB
Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setClob which takes a length parameter.

Parameters:
parameterIndex - index of the first parameter is 1, the second is 2, ...
reader - An object that contains the data to set the parameter value to.
Throws:
SQLException - if a database access error occurs, this method is called on a closed PreparedStatementor if parameterIndex does not correspond to a parameter marker in the SQL statement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setClob
void setClob(String parameterName,
           Reader reader,
           long length)
             throws SQLException
Sets the designated parameter to a Reader object. The reader must contain the number of characters specified by length otherwise a SQLException will be generated when the CallableStatement is executed. This method differs from the setCharacterStream (int, Reader, int) method because it informs the driver that the parameter value should be sent to the server as a CLOB. When the setCharacterStream method is used, the driver may have to do extra work to determine whether the parameter data should be send to the server as a LONGVARCHAR or a CLOB
Parameters:
parameterName - the name of the parameter to be set
reader - An object that contains the data to set the parameter value to.
length - the number of characters in the parameter data.
Throws:
SQLException - if parameterIndex does not correspond to a parameter marker in the SQL statement; if the length specified is less than zero; a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setClob
void setClob(String parameterName,
           Clob x)
             throws SQLException
Sets the designated parameter to the given java.sql.Clob object. The driver converts this to an SQL CLOB value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - a Clob object that maps an SQL CLOB value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setClob
void setClob(String parameterName,
           Reader reader)
             throws SQLException
Sets the designated parameter to a Reader object. This method differs from the setCharacterStream (int, Reader) method because it informs the driver that the parameter value should be sent to the server as a CLOB. When the setCharacterStream method is used, the driver may have to do extra work to determine whether the parameter data should be send to the server as a LONGVARCHAR or a CLOB
Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setClob which takes a length parameter.

Parameters:
parameterName - the name of the parameter
reader - An object that contains the data to set the parameter value to.
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setArray
void setArray(int i,
            Array x)
              throws SQLException
Sets the designated parameter in this RowSet object's command with the given Array value. The driver will convert this to the ARRAY value that the Array object represents before sending it to the database.
Parameters:
i - the first parameter is 1, the second is 2, ...
x - an object representing an SQL array
Throws:
SQLException - if a database access error occurs
setDate
void setDate(int parameterIndex,
           Date x,
           Calendar cal)
             throws SQLException
Sets the designated parameter in this RowSet object's command with the given java.sql.Date value. The driver will convert this to an SQL DATE value, using the given java.util.Calendar object to calculate the date.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
cal - the java.util.Calendar object to use for calculating the date
Throws:
SQLException - if a database access error occurs
setDate
void setDate(String parameterName,
           Date x)
             throws SQLException
Sets the designated parameter to the given java.sql.Date value using the default time zone of the virtual machine that is running the application. The driver converts this to an SQL DATE value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getDate(int)
setDate
void setDate(String parameterName,
           Date x,
           Calendar cal)
             throws SQLException
Sets the designated parameter to the given java.sql.Date value, using the given Calendar object. The driver uses the Calendar object to construct an SQL DATE value, which the driver then sends to the database. With a a Calendar object, the driver can calculate the date taking into account a custom timezone. If no Calendar object is specified, the driver uses the default timezone, which is that of the virtual machine running the application.
Parameters:
parameterName - the name of the parameter
x - the parameter value
cal - the Calendar object the driver will use to construct the date
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getDate(int)
setTime
void setTime(int parameterIndex,
           Time x,
           Calendar cal)
             throws SQLException
Sets the designated parameter in this RowSet object's command with the given java.sql.Time value. The driver will convert this to an SQL TIME value, using the given java.util.Calendar object to calculate it, before sending it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
cal - the java.util.Calendar object to use for calculating the time
Throws:
SQLException - if a database access error occurs
setTime
void setTime(String parameterName,
           Time x)
             throws SQLException
Sets the designated parameter to the given java.sql.Time value. The driver converts this to an SQL TIME value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getTime(int)
setTime
void setTime(String parameterName,
           Time x,
           Calendar cal)
             throws SQLException
Sets the designated parameter to the given java.sql.Time value, using the given Calendar object. The driver uses the Calendar object to construct an SQL TIME value, which the driver then sends to the database. With a a Calendar object, the driver can calculate the time taking into account a custom timezone. If no Calendar object is specified, the driver uses the default timezone, which is that of the virtual machine running the application.
Parameters:
parameterName - the name of the parameter
x - the parameter value
cal - the Calendar object the driver will use to construct the time
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getTime(int)
setTimestamp
void setTimestamp(int parameterIndex,
                Timestamp x,
                Calendar cal)
                  throws SQLException
Sets the designated parameter in this RowSet object's command with the given java.sql.Timestamp value. The driver will convert this to an SQL TIMESTAMP value, using the given java.util.Calendar object to calculate it, before sending it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
cal - the java.util.Calendar object to use for calculating the timestamp
Throws:
SQLException - if a database access error occurs
setTimestamp
void setTimestamp(String parameterName,
                Timestamp x,
                Calendar cal)
                  throws SQLException
Sets the designated parameter to the given java.sql.Timestamp value, using the given Calendar object. The driver uses the Calendar object to construct an SQL TIMESTAMP value, which the driver then sends to the database. With a a Calendar object, the driver can calculate the timestamp taking into account a custom timezone. If no Calendar object is specified, the driver uses the default timezone, which is that of the virtual machine running the application.
Parameters:
parameterName - the name of the parameter
x - the parameter value
cal - the Calendar object the driver will use to construct the timestamp
Throws:
SQLException - if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4
See Also:
ResultSet.getTimestamp(int)
clearParameters
void clearParameters()
                     throws SQLException
Clears the parameters set for this RowSet object's command.
In general, parameter values remain in force for repeated use of a RowSet object. Setting a parameter value automatically clears its previous value. However, in some cases it is useful to immediately release the resources used by the current parameter values, which can be done by calling the method clearParameters.

Throws:
SQLException - if a database access error occurs
execute
void execute()
             throws SQLException
Fills this RowSet object with data.
The execute method may use the following properties to create a connection for reading data: url, data source name, user name, password, transaction isolation, and type map. The execute method may use the following properties to create a statement to execute a command: command, read only, maximum field size, maximum rows, escape processing, and query timeout.

If the required properties have not been set, an exception is thrown. If this method is successful, the current contents of the rowset are discarded and the rowset's metadata is also (re)set. If there are outstanding updates, they are ignored.

If this RowSet object does not maintain a continuous connection with its source of data, it may use a reader (a RowSetReader object) to fill itself with data. In this case, a reader will have been registered with this RowSet object, and the method execute will call on the reader's readData method as part of its implementation.

Throws:
SQLException - if a database access error occurs or any of the properties necessary for making a connection and creating a statement have not been set
addRowSetListener
void addRowSetListener(RowSetListener listener)
Registers the given listener so that it will be notified of events that occur on this RowSet object.
Parameters:
listener - a component that has implemented the RowSetListener interface and wants to be notified when events occur on this RowSet object
See Also:
removeRowSetListener(javax.sql.RowSetListener)
removeRowSetListener
void removeRowSetListener(RowSetListener listener)
Removes the specified listener from the list of components that will be notified when an event occurs on this RowSet object.
Parameters:
listener - a component that has been registered as a listener for this RowSet object
See Also:
addRowSetListener(javax.sql.RowSetListener)
setSQLXML
void setSQLXML(int parameterIndex,
             SQLXML xmlObject)
               throws SQLException
Sets the designated parameter to the given java.sql.SQLXML object. The driver converts this to an SQL XML value when it sends it to the database.
Parameters:
parameterIndex - index of the first parameter is 1, the second is 2, ...
xmlObject - a SQLXML object that maps an SQL XML value
Throws:
SQLException - if a database access error occurs, this method is called on a closed result set, the java.xml.transform.Result, Writer or OutputStream has not been closed for the SQLXML object or if there is an error processing the XML value. The getCause method of the exception may provide a more detailed exception, for example, if the stream does not contain valid XML.
Since:
1.6
setSQLXML
void setSQLXML(String parameterName,
             SQLXML xmlObject)
               throws SQLException
Sets the designated parameter to the given java.sql.SQLXML object. The driver converts this to an SQL XML value when it sends it to the database.
Parameters:
parameterName - the name of the parameter
xmlObject - a SQLXML object that maps an SQL XML value
Throws:
SQLException - if a database access error occurs, this method is called on a closed result set, the java.xml.transform.Result, Writer or OutputStream has not been closed for the SQLXML object or if there is an error processing the XML value. The getCause method of the exception may provide a more detailed exception, for example, if the stream does not contain valid XML.
Since:
1.6
setRowId
void setRowId(int parameterIndex,
            RowId x)
              throws SQLException
Sets the designated parameter to the given java.sql.RowId object. The driver converts this to a SQL ROWID value when it sends it to the database
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the parameter value
Throws:
SQLException - if a database access error occurs
Since:
1.6
setRowId
void setRowId(String parameterName,
            RowId x)
              throws SQLException
Sets the designated parameter to the given java.sql.RowId object. The driver converts this to a SQL ROWID when it sends it to the database.
Parameters:
parameterName - the name of the parameter
x - the parameter value
Throws:
SQLException - if a database access error occurs
Since:
1.6
setNString
void setNString(int parameterIndex,
              String value)
                throws SQLException
Sets the designated paramter to the given String object. The driver converts this to a SQL NCHAR or NVARCHAR or LONGNVARCHAR value (depending on the argument's size relative to the driver's limits on NVARCHAR values) when it sends it to the database.
Parameters:
parameterIndex - of the first parameter is 1, the second is 2, ...
value - the parameter value
Throws:
SQLException - if the driver does not support national character sets; if the driver can detect that a data conversion error could occur ; or if a database access error occurs
Since:
1.6
setNString
void setNString(String parameterName,
              String value)
                throws SQLException
Sets the designated paramter to the given String object. The driver converts this to a SQL NCHAR or NVARCHAR or LONGNVARCHAR
Parameters:
parameterName - the name of the column to be set
value - the parameter value
Throws:
SQLException - if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; or if a database access error occurs
Since:
1.6
setNCharacterStream
void setNCharacterStream(int parameterIndex,
                       Reader value,
                       long length)
                         throws SQLException
Sets the designated parameter to a Reader object. The Reader reads the data till end-of-file is reached. The driver does the necessary conversion from Java character format to the national character set in the database.
Parameters:
parameterIndex - of the first parameter is 1, the second is 2, ...
value - the parameter value
length - the number of characters in the parameter data.
Throws:
SQLException - if the driver does not support national character sets; if the driver can detect that a data conversion error could occur ; or if a database access error occurs
Since:
1.6
setNCharacterStream
void setNCharacterStream(String parameterName,
                       Reader value,
                       long length)
                         throws SQLException
Sets the designated parameter to a Reader object. The Reader reads the data till end-of-file is reached. The driver does the necessary conversion from Java character format to the national character set in the database.
Parameters:
parameterName - the name of the column to be set
value - the parameter value
length - the number of characters in the parameter data.
Throws:
SQLException - if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; or if a database access error occurs
Since:
1.6
setNCharacterStream
void setNCharacterStream(String parameterName,
                       Reader value)
                         throws SQLException
Sets the designated parameter to a Reader object. The Reader reads the data till end-of-file is reached. The driver does the necessary conversion from Java character format to the national character set in the database.
Note: This stream object can either be a standard Java stream object or your own subclass that implements the standard interface.

Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setNCharacterStream which takes a length parameter.

Parameters:
parameterName - the name of the parameter
value - the parameter value
Throws:
SQLException - if the driver does not support national character sets; if the driver can detect that a data conversion error could occur ; if a database access error occurs; or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setNClob
void setNClob(String parameterName,
            NClob value)
              throws SQLException
Sets the designated parameter to a java.sql.NClob object. The object implements the java.sql.NClob interface. This NClob object maps to a SQL NCLOB.
Parameters:
parameterName - the name of the column to be set
value - the parameter value
Throws:
SQLException - if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; or if a database access error occurs
Since:
1.6
setNClob
void setNClob(String parameterName,
            Reader reader,
            long length)
              throws SQLException
Sets the designated parameter to a Reader object. The reader must contain the number of characters specified by length otherwise a SQLException will be generated when the CallableStatement is executed. This method differs from the setCharacterStream (int, Reader, int) method because it informs the driver that the parameter value should be sent to the server as a NCLOB. When the setCharacterStream method is used, the driver may have to do extra work to determine whether the parameter data should be send to the server as a LONGNVARCHAR or a NCLOB
Parameters:
parameterName - the name of the parameter to be set
reader - An object that contains the data to set the parameter value to.
length - the number of characters in the parameter data.
Throws:
SQLException - if parameterIndex does not correspond to a parameter marker in the SQL statement; if the length specified is less than zero; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setNClob
void setNClob(String parameterName,
            Reader reader)
              throws SQLException
Sets the designated parameter to a Reader object. This method differs from the setCharacterStream (int, Reader) method because it informs the driver that the parameter value should be sent to the server as a NCLOB. When the setCharacterStream method is used, the driver may have to do extra work to determine whether the parameter data should be send to the server as a LONGNVARCHAR or a NCLOB
Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setNClob which takes a length parameter.

Parameters:
parameterName - the name of the parameter
reader - An object that contains the data to set the parameter value to.
Throws:
SQLException - if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed CallableStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setNClob
void setNClob(int parameterIndex,
            Reader reader,
            long length)
              throws SQLException
Sets the designated parameter to a Reader object. The reader must contain the number of characters specified by length otherwise a SQLException will be generated when the PreparedStatement is executed. This method differs from the setCharacterStream (int, Reader, int) method because it informs the driver that the parameter value should be sent to the server as a NCLOB. When the setCharacterStream method is used, the driver may have to do extra work to determine whether the parameter data should be sent to the server as a LONGNVARCHAR or a NCLOB
Parameters:
parameterIndex - index of the first parameter is 1, the second is 2, ...
reader - An object that contains the data to set the parameter value to.
length - the number of characters in the parameter data.
Throws:
SQLException - if parameterIndex does not correspond to a parameter marker in the SQL statement; if the length specified is less than zero; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed PreparedStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setNClob
void setNClob(int parameterIndex,
            NClob value)
              throws SQLException
Sets the designated parameter to a java.sql.NClob object. The driver converts this to a SQL NCLOB value when it sends it to the database.
Parameters:
parameterIndex - of the first parameter is 1, the second is 2, ...
value - the parameter value
Throws:
SQLException - if the driver does not support national character sets; if the driver can detect that a data conversion error could occur ; or if a database access error occurs
Since:
1.6
setNClob
void setNClob(int parameterIndex,
            Reader reader)
              throws SQLException
Sets the designated parameter to a Reader object. This method differs from the setCharacterStream (int, Reader) method because it informs the driver that the parameter value should be sent to the server as a NCLOB. When the setCharacterStream method is used, the driver may have to do extra work to determine whether the parameter data should be sent to the server as a LONGNVARCHAR or a NCLOB
Note: Consult your JDBC driver documentation to determine if it might be more efficient to use a version of setNClob which takes a length parameter.

Parameters:
parameterIndex - index of the first parameter is 1, the second is 2, ...
reader - An object that contains the data to set the parameter value to.
Throws:
SQLException - if parameterIndex does not correspond to a parameter marker in the SQL statement; if the driver does not support national character sets; if the driver can detect that a data conversion error could occur; if a database access error occurs or this method is called on a closed PreparedStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.6
setURL
void setURL(int parameterIndex,
          URL x)
            throws SQLException
Sets the designated parameter to the given java.net.URL value. The driver converts this to an SQL DATALINK value when it sends it to the database.
Parameters:
parameterIndex - the first parameter is 1, the second is 2, ...
x - the java.net.URL object to be set
Throws:
SQLException - if a database access error occurs or this method is called on a closed PreparedStatement
SQLFeatureNotSupportedException - if the JDBC driver does not support this method
Since:
1.4


 Donate Now If we all gave 30 kr, the fundraiser would be over in an hour. If Wikipedia is useful to you, please take one minute to keep it online and ad-free.
DONATE NOW
Database
From Wikipedia, the free encyclopedia
A database is an organized collection of data.[1] The data is typically organized to model aspects of reality in a way that supports processes requiring information. For example, modelling the availability of rooms in hotels in a way that supports finding a hotel with vacancies.

Database management systems are computer software applications that interact with the user, other applications, and the database itself to capture and analyze data. A general-purpose DBMS is designed to allow the definition, creation, querying, update, and administration of databases. Well-known DBMSs include MySQL, PostgreSQL, Microsoft SQL Server, Oracle, Sybase and IBM DB2. A database is not generally portable across different DBMSs, but different DBMS can interoperate by using standards such as SQL and ODBC or JDBC to allow a single application to work with more than one DBMS. Database management systems are often classified according to the database model that they support; the most popular database systems since the 1980s have all supported the relational model as represented by the SQL language. Sometimes a DBMS is loosely referred to as a 'database'.

Contents  [hide] 
1 Terminology and overview
2 Applications
3 General-purpose and special-purpose DBMSs
4 History
4.1 1960s, navigational DBMS
4.2 1970s, relational DBMS
4.3 Integrated approach
4.4 Late 1970s, SQL DBMS
4.5 1980s, on the desktop
4.6 1980s, object-oriented
4.7 2000s, NoSQL and NewSQL
5 Research
6 Examples
7 Design and modeling
7.1 Models
7.2 External, conceptual, and internal views
8 Languages
9 Performance, security, and availability
9.1 Storage
9.1.1 Materialized views
9.1.2 Replication
9.2 Security
9.3 Transactions and concurrency
9.4 Migration
9.5 Building, maintaining, and tuning
9.6 Backup and restore
9.7 Other
10 See also
11 References
12 Further reading
13 External links
Terminology and overview[edit]
Formally, a "database" refers to a set of related data and the way it is organized. Access to this data is usually provided by a "database management system" (DBMS) consisting of an integrated set of computer software that allows users to interact with one or more databases and provides access to all of the data contained in the database (although restrictions may exist that limit access to particular data). The DBMS provides various functions that allow entry, storage and retrieval of large quantities of information as well as provide ways to manage how that information is organized.

Because of the close relationship between them, the term "database" is often used casually to refer to both a database and the DBMS used to manipulate it.

Outside the world of professional information technology, the term database is often used to refer to any collection of related data (such as a spreadsheet or a card index). This article is concerned only with databases where the size and usage requirements necessitate use of a database management system.[2]

Existing DBMSs provide various functions that allow management of a database and its data which can be classified into four main functional groups:

Data definition – Creation, modification and removal of definitions that define the organization of the data.
Update – Insertion, modification, and deletion of the actual data.[3]
Retrieval – Providing information in a form directly usable or for further processing by other applications. The retrieved data may be made available in a form basically the same as it is stored in the database or in a new form obtained by altering or combining existing data from the database.[4]
Administration – Registering and monitoring users, enforcing data security, monitoring performance, maintaining data integrity, dealing with concurrency control, and recovering information that has been corrupted by some event such as an unexpected system failure.[5]
Both a database and its DBMS conform to the principles of a particular database model.[6] "Database system" refers collectively to the database model, database management system, and database.[7]

Physically, database servers are dedicated computers that hold the actual databases and run only the DBMS and related software. Database servers are usually multiprocessor computers, with generous memory and RAID disk arrays used for stable storage. RAID is used for recovery of data if any of the disks fail. Hardware database accelerators, connected to one or more servers via a high-speed channel, are also used in large volume transaction processing environments. DBMSs are found at the heart of most database applications. DBMSs may be built around a custom multitasking kernel with built-in networking support, but modern DBMSs typically rely on a standard operating system to provide these functions.[citation needed] Since DBMSs comprise a significant economical market, computer and storage vendors often take into account DBMS requirements in their own development plans.[citation needed]

Databases and DBMSs can be categorized according to the database model(s) that they support (such as relational or XML), the type(s) of computer they run on (from a server cluster to a mobile phone), the query language(s) used to access the database (such as SQL or XQuery), and their internal engineering, which affects performance, scalability, resilience, and security.

Applications[edit]

This section does not cite any references or sources. Please help improve this section by adding citations to reliable sources. Unsourced material may be challenged and removed. (March 2013)
Databases are used to support internal operations of organizations and to underpin online interactions with customers and suppliers (see Enterprise software).

Databases are used to hold administrative information and more specialized data, such as engineering data or economic models. Examples of database applications include computerized library systems, flight reservation systems and computerized parts inventory systems.

Application areas of DBMS

1. Banking: For customer information, accounts, and loans, and banking transactions.

2. Airlines: For reservations and schedule information. Airlines were among the first to use databases in a geographically distributed manner - terminals situated around the world accessed the central database system through phone lines and other data networks.

3. Universities: For student information, course registrations, and grades.

4. Credit card transactions: For purchases on credit cards and generation of monthly statements.

5. Telecommunication: For keeping records of calls made, generating monthly bills, maintaining balances on prepaid calling cards, and storing information about the communication networks.

6. Finance: For storing information about holdings, sales, and purchases of financial instruments such as stocks and bonds.

7. Sales: For customer, product, and purchase information.

8. Manufacturing: For management of supply chain and for tracking production of items in factories, inventories of items in warehouses / stores, and orders for items.

9. Human resources: For information about employees, salaries, payroll taxes and benefits, and for generation of paychecks.

General-purpose and special-purpose DBMSs[edit]
A DBMS has evolved into a complex software system and its development typically requires thousands of person-years of development effort.[8] Some general-purpose DBMSs such as Adabas, Oracle and DB2 have been undergoing upgrades since the 1970s. General-purpose DBMSs aim to meet the needs of as many applications as possible, which adds to the complexity. However, the fact that their development cost can be spread over a large number of users means that they are often the most cost-effective approach. However, a general-purpose DBMS is not always the optimal solution: in some cases a general-purpose DBMS may introduce unnecessary overhead. Therefore, there are many examples of systems that use special-purpose databases. A common example is an email system that performs many of the functions of a general-purpose DBMS such as the insertion and deletion of messages composed of various items of data or associating messages with a particular email address; but these functions are limited to what is required to handle email and don't provide the user with the all of the functionality that would be available using a general-purpose DBMS.

Many other databases have application software that accesses the database on behalf of end-users, without exposing the DBMS interface directly. Application programmers may use a wire protocol directly, or more likely through an application programming interface. Database designers and database administrators interact with the DBMS through dedicated interfaces to build and maintain the applications' databases, and thus need some more knowledge and understanding about how DBMSs operate and the DBMSs' external interfaces and tuning parameters.

History[edit]
Following the technology progress in the areas of processors, computer memory, computer storage and computer networks, the sizes, capabilities, and performance of databases and their respective DBMSs have grown in orders of magnitude. The development of database technology can be divided into three eras based on data model or structure: navigational,[9] SQL/relational, and post-relational.

The two main early navigational data models were the hierarchical model, epitomized by IBM's IMS system, and the CODASYL model (network model), implemented in a number of products such as IDMS.

The relational model, first proposed in 1970 by Edgar F. Codd, departed from this tradition by insisting that applications should search for data by content, rather than by following links. The relational model employs sets of ledger-style tables, each used for a different type of entity. Only in the mid-1980s did computing hardware become powerful enough to allow the wide deployment of relational systems (DBMSs plus applications). By the early 1990s, however, relational systems dominated in all large-scale data processing applications, and as of 2015 they remain dominant : Oracle, mySQL and SQL server are the top DBMS.[10] The dominant database language, standardised SQL for the relational model, has influenced database languages for other data models.[citation needed]

Object databases were developed in the 1980s to overcome the inconvenience of object-relational impedance mismatch, which led to the coining of the term "post-relational" and also the development of hybrid object-relational databases.

The next generation of post-relational databases in the late 2000s became known as NoSQL databases, introducing fast key-value stores and document-oriented databases. A competing "next generation" known as NewSQL databases attempted new implementations that retained the relational/SQL model while aiming to match the high performance of NoSQL compared to commercially available relational DBMSs.

1960s, navigational DBMS[edit]
Further information: Navigational database

Basic structure of navigational CODASYL database model
The introduction of the term database coincided with the availability of direct-access storage (disks and drums) from the mid-1960s onwards. The term represented a contrast with the tape-based systems of the past, allowing shared interactive use rather than daily batch processing. The Oxford English dictionary cites[11] a 1962 report by the System Development Corporation of California as the first to use the term "data-base" in a specific technical sense.

As computers grew in speed and capability, a number of general-purpose database systems emerged; by the mid-1960s a number of such systems had come into commercial use. Interest in a standard began to grow, and Charles Bachman, author of one such product, the Integrated Data Store (IDS), founded the "Database Task Group" within CODASYL, the group responsible for the creation and standardization of COBOL. In 1971 the Database Task Group delivered their standard, which generally became known as the "CODASYL approach", and soon a number of commercial products based on this approach entered the market.

The CODASYL approach relied on the "manual" navigation of a linked data set which was formed into a large network. Applications could find records by one of three methods:

Use of a primary key (known as a CALC key, typically implemented by hashing)
Navigating relationships (called sets) from one record to another
Scanning all the records in a sequential order
Later systems added B-Trees to provide alternate access paths. Many CODASYL databases also added a very straightforward query language. However, in the final tally, CODASYL was very complex and required significant training and effort to produce useful applications.

IBM also had their own DBMS in 1968, known as Information Management System (IMS). IMS was a development of software written for the Apollo program on the System/360. IMS was generally similar in concept to CODASYL, but used a strict hierarchy for its model of data navigation instead of CODASYL's network model. Both concepts later became known as navigational databases due to the way data was accessed, and Bachman's 1973 Turing Award presentation was The Programmer as Navigator. IMS is classified[by whom?] as a hierarchical database. IDMS and Cincom Systems' TOTAL database are classified as network databases. IMS remains in use as of 2014.[12]

1970s, relational DBMS[edit]
Edgar Codd worked at IBM in San Jose, California, in one of their offshoot offices that was primarily involved in the development of hard disk systems. He was unhappy with the navigational model of the CODASYL approach, notably the lack of a "search" facility. In 1970, he wrote a number of papers that outlined a new approach to database construction that eventually culminated in the groundbreaking A Relational Model of Data for Large Shared Data Banks.[13]

In this paper, he described a new system for storing and working with large databases. Instead of records being stored in some sort of linked list of free-form records as in CODASYL, Codd's idea was to use a "table" of fixed-length records, with each table used for a different type of entity. A linked-list system would be very inefficient when storing "sparse" databases where some of the data for any one record could be left empty. The relational model solved this by splitting the data into a series of normalized tables (or relations), with optional elements being moved out of the main table to where they would take up room only if needed. Data may be freely inserted, deleted and edited in these tables, with the DBMS doing whatever maintenance needed to present a table view to the application/user.


In the relational model, records are "linked" using virtual keys not stored in the database but defined as needed between the data contained in the records.
The relational model also allowed the content of the database to evolve without constant rewriting of links and pointers. The relational part comes from entities referencing other entities in what is known as one-to-many relationship, like a traditional hierarchical model, and many-to-many relationship, like a navigational (network) model. Thus, a relational model can express both hierarchical and navigational models, as well as its native tabular model, allowing for pure or combined modeling in terms of these three models, as the application requires.

For instance, a common use of a database system is to track information about users, their name, login information, various addresses and phone numbers. In the navigational approach all of these data would be placed in a single record, and unused items would simply not be placed in the database. In the relational approach, the data would be normalized into a user table, an address table and a phone number table (for instance). Records would be created in these optional tables only if the address or phone numbers were actually provided.

Linking the information back together is the key to this system. In the relational model, some bit of information was used as a "key", uniquely defining a particular record. When information was being collected about a user, information stored in the optional tables would be found by searching for this key. For instance, if the login name of a user is unique, addresses and phone numbers for that user would be recorded with the login name as its key. This simple "re-linking" of related data back into a single collection is something that traditional computer languages are not designed for.

Just as the navigational approach would require programs to loop in order to collect records, the relational approach would require loops to collect information about any one record. Codd's solution to the necessary looping was a set-oriented language, a suggestion that would later spawn the ubiquitous SQL. Using a branch of mathematics known as tuple calculus, he demonstrated that such a system could support all the operations of normal databases (inserting, updating etc.) as well as providing a simple system for finding and returning sets of data in a single operation.

Codd's paper was picked up by two people at Berkeley, Eugene Wong and Michael Stonebraker. They started a project known as INGRES using funding that had already been allocated for a geographical database project and student programmers to produce code. Beginning in 1973, INGRES delivered its first test products which were generally ready for widespread use in 1979. INGRES was similar to System R in a number of ways, including the use of a "language" for data access, known as QUEL. Over time, INGRES moved to the emerging SQL standard.

IBM itself did one test implementation of the relational model, PRTV, and a production one, Business System 12, both now discontinued. Honeywell wrote MRDS for Multics, and now there are two new implementations: Alphora Dataphor and Rel. Most other DBMS implementations usually called relational are actually SQL DBMSs.

In 1970, the University of Michigan began development of the MICRO Information Management System[14] based on D.L. Childs' Set-Theoretic Data model.[15][16][17] Micro was used to manage very large data sets by the US Department of Labor, the U.S. Environmental Protection Agency, and researchers from the University of Alberta, the University of Michigan, and Wayne State University. It ran on IBM mainframe computers using the Michigan Terminal System.[18] The system remained in production until 1998.

Integrated approach[edit]
Main article: Database machine
In the 1970s and 1980s attempts were made to build database systems with integrated hardware and software. The underlying philosophy was that such integration would provide higher performance at lower cost. Examples were IBM System/38, the early offering of Teradata, and the Britton Lee, Inc. database machine.

Another approach to hardware support for database management was ICL's CAFS accelerator, a hardware disk controller with programmable search capabilities. In the long term, these efforts were generally unsuccessful because specialized database machines could not keep pace with the rapid development and progress of general-purpose computers. Thus most database systems nowadays are software systems running on general-purpose hardware, using general-purpose computer data storage. However this idea is still pursued for certain applications by some companies like Netezza and Oracle (Exadata).

Late 1970s, SQL DBMS[edit]
IBM started working on a prototype system loosely based on Codd's concepts as System R in the early 1970s. The first version was ready in 1974/5, and work then started on multi-table systems in which the data could be split so that all of the data for a record (some of which is optional) did not have to be stored in a single large "chunk". Subsequent multi-user versions were tested by customers in 1978 and 1979, by which time a standardized query language – SQL[citation needed] – had been added. Codd's ideas were establishing themselves as both workable and superior to CODASYL, pushing IBM to develop a true production version of System R, known as SQL/DS, and, later, Database 2 (DB2).

Larry Ellison's Oracle started from a different chain, based on IBM's papers on System R, and beat IBM to market when the first version was released in 1978.[citation needed]

Stonebraker went on to apply the lessons from INGRES to develop a new database, Postgres, which is now known as PostgreSQL. PostgreSQL is often used for global mission critical applications (the .org and .info domain name registries use it as their primary data store, as do many large companies and financial institutions).

In Sweden, Codd's paper was also read and Mimer SQL was developed from the mid-1970s at Uppsala University. In 1984, this project was consolidated into an independent enterprise. In the early 1980s, Mimer introduced transaction handling for high robustness in applications, an idea that was subsequently implemented on most other DBMSs.

Another data model, the entity–relationship model, emerged in 1976 and gained popularity for database design as it emphasized a more familiar description than the earlier relational model. Later on, entity–relationship constructs were retrofitted as a data modeling construct for the relational model, and the difference between the two have become irrelevant.[citation needed]

1980s, on the desktop[edit]
The 1980s ushered in the age of desktop computing. The new computers empowered their users with spreadsheets like Lotus 1-2-3 and database software like dBASE. The dBASE product was lightweight and easy for any computer user to understand out of the box. C. Wayne Ratliff the creator of dBASE stated: "dBASE was different from programs like BASIC, C, FORTRAN, and COBOL in that a lot of the dirty work had already been done. The data manipulation is done by dBASE instead of by the user, so the user can concentrate on what he is doing, rather than having to mess with the dirty details of opening, reading, and closing files, and managing space allocation."[19] dBASE was one of the top selling software titles in the 1980s and early 1990s.

1980s, object-oriented[edit]
The 1980s, along with a rise in object-oriented programming, saw a growth in how data in various databases were handled. Programmers and designers began to treat the data in their databases as objects. That is to say that if a person's data were in a database, that person's attributes, such as their address, phone number, and age, were now considered to belong to that person instead of being extraneous data. This allows for relations between data to be relations to objects and their attributes and not to individual fields.[20] The term "object-relational impedance mismatch" described the inconvenience of translating between programmed objects and database tables. Object databases and object-relational databases attempt to solve this problem by providing an object-oriented language (sometimes as extensions to SQL) that programmers can use as alternative to purely relational SQL. On the programming side, libraries known as object-relational mappings (ORMs) attempt to solve the same problem.

2000s, NoSQL and NewSQL[edit]
Main articles: NoSQL and NewSQL
The next generation of post-relational databases in the 2000s became known as NoSQL databases, including fast key-value stores and document-oriented databases.

XML databases are a type of structured document-oriented database that allows querying based on XML document attributes. XML databases are mostly used in enterprise database management, where XML is being used as the machine-to-machine data interoperability standard. XML database management systems include commercial software MarkLogic and Oracle Berkeley DB XML, and a free use software Clusterpoint Distributed XML/JSON Database. All are enterprise software database platforms and support industry standard ACID-compliant transaction processing with strong database consistency characteristics and high level of database security.[21][22][23]

NoSQL databases are often very fast, do not require fixed table schemas, avoid join operations by storing denormalized data, and are designed to scale horizontally. The most popular NoSQL systems include MongoDB, Couchbase, Riak, Memcached, Redis, CouchDB, Hazelcast, Apache Cassandra and HBase,[24] which are all open-source software products.

In recent years there was a high demand for massively distributed databases with high partition tolerance but according to the CAP theorem it is impossible for a distributed system to simultaneously provide consistency, availability and partition tolerance guarantees. A distributed system can satisfy any two of these guarantees at the same time, but not all three. For that reason many NoSQL databases are using what is called eventual consistency to provide both availability and partition tolerance guarantees with a reduced level of data consistency.

NewSQL is a class of modern relational databases that aims to provide the same scalable performance of NoSQL systems for online transaction processing (read-write) workloads while still using SQL and maintaining the ACID guarantees of a traditional database system. Such databases include ScaleBase, Clustrix, EnterpriseDB, MemSQL, NuoDB[25] and VoltDB.

Research[edit]
Database technology has been an active research topic since the 1960s, both in academia and in the research and development groups of companies (for example IBM Research). Research activity includes theory and development of prototypes. Notable research topics have included models, the atomic transaction concept and related concurrency control techniques, query languages and query optimization methods, RAID, and more.

The database research area has several dedicated academic journals (for example, ACM Transactions on Database Systems-TODS, Data and Knowledge Engineering-DKE) and annual conferences (e.g., ACM SIGMOD, ACM PODS, VLDB, IEEE ICDE).

Examples[edit]
One way to classify databases involves the type of their contents, for example: bibliographic, document-text, statistical, or multimedia objects. Another way is by their application area, for example: accounting, music compositions, movies, banking, manufacturing, or insurance. A third way is by some technical aspect, such as the database structure or interface type. This section lists a few of the adjectives used to characterize different kinds of databases.

An in-memory database is a database that primarily resides in main memory, but is typically backed-up by non-volatile computer data storage. Main memory databases are faster than disk databases, and so are often used where response time is critical, such as in telecommunications network equipment.[26] SAP HANA platform is a very hot topic for in-memory database. By May 2012, HANA was able to run on servers with 100TB main memory powered by IBM. The co founder of the company claimed that the system was big enough to run the 8 largest SAP customers.
An active database includes an event-driven architecture which can respond to conditions both inside and outside the database. Possible uses include security monitoring, alerting, statistics gathering and authorization. Many databases provide active database features in the form of database triggers.
A cloud database relies on cloud technology. Both the database and most of its DBMS reside remotely, "in the cloud", while its applications are both developed by programmers and later maintained and utilized by (application's) end-users through a web browser and Open APIs.
Data warehouses archive data from operational databases and often from external sources such as market research firms. The warehouse becomes the central source of data for use by managers and other end-users who may not have access to operational data. For example, sales data might be aggregated to weekly totals and converted from internal product codes to use UPCs so that they can be compared with ACNielsen data. Some basic and essential components of data warehousing include extracting, analyzing, and mining data, transforming, loading and managing data so as to make them available for further use.
A deductive database combines logic programming with a relational database, for example by using the Datalog language.
A distributed database is one in which both the data and the DBMS span multiple computers.
A document-oriented database is designed for storing, retrieving, and managing document-oriented, or semi structured data, information. Document-oriented databases are one of the main categories of NoSQL databases.
An embedded database system is a DBMS which is tightly integrated with an application software that requires access to stored data in such a way that the DBMS is hidden from the application’s end-users and requires little or no ongoing maintenance.[27]
End-user databases consist of data developed by individual end-users. Examples of these are collections of documents, spreadsheets, presentations, multimedia, and other files. Several products exist to support such databases. Some of them are much simpler than full-fledged DBMSs, with more elementary DBMS functionality.
A federated database system comprises several distinct databases, each with its own DBMS. It is handled as a single database by a federated database management system (FDBMS), which transparently integrates multiple autonomous DBMSs, possibly of different types (in which case it would also be a heterogeneous database system), and provides them with an integrated conceptual view.
Sometimes the term multi-database is used as a synonym to federated database, though it may refer to a less integrated (e.g., without an FDBMS and a managed integrated schema) group of databases that cooperate in a single application. In this case typically middleware is used for distribution, which typically includes an atomic commit protocol (ACP), e.g., the two-phase commit protocol, to allow distributed (global) transactions across the participating databases.
A graph database is a kind of NoSQL database that uses graph structures with nodes, edges, and properties to represent and store information. General graph databases that can store any graph are distinct from specialized graph databases such as triplestores and network databases.
An array DBMS is a kind of NoSQL DBMS that allows to model, store, and retrieve (usually large) multi-dimensional arrays such as satellite images and climate simulation output.
In a hypertext or hypermedia database, any word or a piece of text representing an object, e.g., another piece of text, an article, a picture, or a film, can be hyperlinked to that object. Hypertext databases are particularly useful for organizing large amounts of disparate information. For example, they are useful for organizing online encyclopedias, where users can conveniently jump around the text. The World Wide Web is thus a large distributed hypertext database.
A knowledge base (abbreviated KB, kb or Δ[28][29]) is a special kind of database for knowledge management, providing the means for the computerized collection, organization, and retrieval of knowledge. Also a collection of data representing problems with their solutions and related experiences.
A mobile database can be carried on or synchronized from a mobile computing device.
Operational databases store detailed data about the operations of an organization. They typically process relatively high volumes of updates using transactions. Examples include customer databases that record contact, credit, and demographic information about a business' customers, personnel databases that hold information such as salary, benefits, skills data about employees, enterprise resource planning systems that record details about product components, parts inventory, and financial databases that keep track of the organization's money, accounting and financial dealings.
A parallel database seeks to improve performance through parallelization for tasks such as loading data, building indexes and evaluating queries.
The major parallel DBMS architectures which are induced by the underlying hardware architecture are:
Shared memory architecture, where multiple processors share the main memory space, as well as other data storage.
Shared disk architecture, where each processing unit (typically consisting of multiple processors) has its own main memory, but all units share the other storage.
Shared nothing architecture, where each processing unit has its own main memory and other storage.
Probabilistic databases employ fuzzy logic to draw inferences from imprecise data.
Real-time databases process transactions fast enough for the result to come back and be acted on right away.
A spatial database can store the data with multidimensional features. The queries on such data include location based queries, like "Where is the closest hotel in my area?".
A temporal database has built-in time aspects, for example a temporal data model and a temporal version of SQL. More specifically the temporal aspects usually include valid-time and transaction-time.
A terminology-oriented database builds upon an object-oriented database, often customized for a specific field.
An unstructured data database is intended to store in a manageable and protected way diverse objects that do not fit naturally and conveniently in common databases. It may include email messages, documents, journals, multimedia objects, etc. The name may be misleading since some objects can be highly structured. However, the entire possible object collection does not fit into a predefined structured framework. Most established DBMSs now support unstructured data in various ways, and new dedicated DBMSs are emerging.
Design and modeling[edit]
Main article: Database design
The first task of a database designer is to produce a conceptual data model that reflects the structure of the information to be held in the database. A common approach to this is to develop an entity-relationship model, often with the aid of drawing tools. Another popular approach is the Unified Modeling Language. A successful data model will accurately reflect the possible state of the external world being modeled: for example, if people can have more than one phone number, it will allow this information to be captured. Designing a good conceptual data model requires a good understanding of the application domain; it typically involves asking deep questions about the things of interest to an organisation, like "can a customer also be a supplier?", or "if a product is sold with two different forms of packaging, are those the same product or different products?", or "if a plane flies from New York to Dubai via Frankfurt, is that one flight or two (or maybe even three)?". The answers to these questions establish definitions of the terminology used for entities (customers, products, flights, flight segments) and their relationships and attributes.

Producing the conceptual data model sometimes involves input from business processes, or the analysis of workflow in the organization. This can help to establish what information is needed in the database, and what can be left out. For example, it can help when deciding whether the database needs to hold historic data as well as current data.

Having produced a conceptual data model that users are happy with, the next stage is to translate this into a schema that implements the relevant data structures within the database. This process is often called logical database design, and the output is a logical data model expressed in the form of a schema. Whereas the conceptual data model is (in theory at least) independent of the choice of database technology, the logical data model will be expressed in terms of a particular database model supported by the chosen DBMS. (The terms data model and database model are often used interchangeably, but in this article we use data model for the design of a specific database, and database model for the modelling notation used to express that design.)

The most popular database model for general-purpose databases is the relational model, or more precisely, the relational model as represented by the SQL language. The process of creating a logical database design using this model uses a methodical approach known as normalization. The goal of normalization is to ensure that each elementary "fact" is only recorded in one place, so that insertions, updates, and deletions automatically maintain consistency.

The final stage of database design is to make the decisions that affect performance, scalability, recovery, security, and the like. This is often called physical database design. A key goal during this stage is data independence, meaning that the decisions made for performance optimization purposes should be invisible to end-users and applications. Physical design is driven mainly by performance requirements, and requires a good knowledge of the expected workload and access patterns, and a deep understanding of the features offered by the chosen DBMS.

Another aspect of physical database design is security. It involves both defining access control to database objects as well as defining security levels and methods for the data itself.

Models[edit]
Main article: Database model

Collage of five types of database models
A database model is a type of data model that determines the logical structure of a database and fundamentally determines in which manner data can be stored, organized, and manipulated. The most popular example of a database model is the relational model (or the SQL approximation of relational), which uses a table-based format.

Common logical data models for databases include:

Hierarchical database model
Network model
Relational model
Entity–relationship model
Enhanced entity–relationship model
Object model
Document model
Entity–attribute–value model
Star schema
An object-relational database combines the two related structures.

Physical data models include:

Inverted index
Flat file
Other models include:

Associative model
Multidimensional model
Array model
Multivalue model
Semantic model
XML database
External, conceptual, and internal views[edit]

Traditional view of data[30]
A database management system provides three views of the database data:

The external level defines how each group of end-users sees the organization of data in the database. A single database can have any number of views at the external level.
The conceptual level unifies the various external views into a compatible global view.[31] It provides the synthesis of all the external views. It is out of the scope of the various database end-users, and is rather of interest to database application developers and database administrators.
The internal level (or physical level) is the internal organization of data inside a DBMS (see Implementation section below). It is concerned with cost, performance, scalability and other operational matters. It deals with storage layout of the data, using storage structures such as indexes to enhance performance. Occasionally it stores data of individual views (materialized views), computed from generic data, if performance justification exists for such redundancy. It balances all the external views' performance requirements, possibly conflicting, in an attempt to optimize overall performance across all activities.
While there is typically only one conceptual (or logical) and physical (or internal) view of the data, there can be any number of different external views. This allows users to see database information in a more business-related way rather than from a technical, processing viewpoint. For example, a financial department of a company needs the payment details of all employees as part of the company's expenses, but does not need details about employees that are the interest of the human resources department. Thus different departments need different views of the company's database.

The three-level database architecture relates to the concept of data independence which was one of the major initial driving forces of the relational model. The idea is that changes made at a certain level do not affect the view at a higher level. For example, changes in the internal level do not affect application programs written using conceptual level interfaces, which reduces the impact of making physical changes to improve performance.

The conceptual view provides a level of indirection between internal and external. On one hand it provides a common view of the database, independent of different external view structures, and on the other hand it abstracts away details of how the data is stored or managed (internal level). In principle every level, and even every external view, can be presented by a different data model. In practice usually a given DBMS uses the same data model for both the external and the conceptual levels (e.g., relational model). The internal level, which is hidden inside the DBMS and depends on its implementation (see Implementation section below), requires a different level of detail and uses its own types of data structure types.

Separating the external, conceptual and internal levels was a major feature of the relational database model implementations that dominate 21st century databases.[31]

Languages[edit]
Database languages are special-purpose languages, which do one or more of the following:

Data definition language – defines data types and the relationships among them
Data manipulation language – performs tasks such as inserting, updating, or deleting data occurrences
Query language – allows searching for information and computing derived information
Database languages are specific to a particular data model. Notable examples include:

SQL combines the roles of data definition, data manipulation, and query in a single language. It was one of the first commercial languages for the relational model, although it departs in some respects from the relational model as described by Codd (for example, the rows and columns of a table can be ordered). SQL became a standard of the American National Standards Institute (ANSI) in 1986, and of the International Organization for Standardization (ISO) in 1987. The standards have been regularly enhanced since and is supported (with varying degrees of conformance) by all mainstream commercial relational DBMSs.[32][33]
OQL is an object model language standard (from the Object Data Management Group). It has influenced the design of some of the newer query languages like JDOQL and EJB QL.
XQuery is a standard XML query language implemented by XML database systems such as MarkLogic and eXist, by relational databases with XML capability such as Oracle and DB2, and also by in-memory XML processors such as Saxon.
SQL/XML combines XQuery with SQL.[34]
A database language may also incorporate features like:

DBMS-specific Configuration and storage engine management
Computations to modify query results, like counting, summing, averaging, sorting, grouping, and cross-referencing
Constraint enforcement (e.g. in an automotive database, only allowing one engine type per car)
Application programming interface version of the query language, for programmer convenience
Performance, security, and availability[edit]
Because of the critical importance of database technology to the smooth running of an enterprise, database systems include complex mechanisms to deliver the required performance, security, and availability, and allow database administrators to control the use of these features.

Storage[edit]
Main articles: Computer data storage and Database engine
Database storage is the container of the physical materialization of a database. It comprises the internal (physical) level in the database architecture. It also contains all the information needed (e.g., metadata, "data about the data", and internal data structures) to reconstruct the conceptual level and external level from the internal level when needed. Putting data into permanent storage is generally the responsibility of the database engine a.k.a. "storage engine". Though typically accessed by a DBMS through the underlying operating system (and often utilizing the operating systems' file systems as intermediates for storage layout), storage properties and configuration setting are extremely important for the efficient operation of the DBMS, and thus are closely maintained by database administrators. A DBMS, while in operation, always has its database residing in several types of storage (e.g., memory and external storage). The database data and the additional needed information, possibly in very large amounts, are coded into bits. Data typically reside in the storage in structures that look completely different from the way the data look in the conceptual and external levels, but in ways that attempt to optimize (the best possible) these levels' reconstruction when needed by users and programs, as well as for computing additional types of needed information from the data (e.g., when querying the database).

Some DBMSs support specifying which character encoding was used to store data, so multiple encodings can be used in the same database.

Various low-level database storage structures are used by the storage engine to serialize the data model so it can be written to the medium of choice. Techniques such as indexing may be used to improve performance. Conventional storage is row-oriented, but there are also column-oriented and correlation databases.

Materialized views[edit]
Main article: Materialized view
Often storage redundancy is employed to increase performance. A common example is storing materialized views, which consist of frequently needed external views or query results. Storing such views saves the expensive computing of them each time they are needed. The downsides of materialized views are the overhead incurred when updating them to keep them synchronized with their original updated database data, and the cost of storage redundancy.

Replication[edit]
Main article: Database replication
Occasionally a database employs storage redundancy by database objects replication (with one or more copies) to increase data availability (both to improve performance of simultaneous multiple end-user accesses to a same database object, and to provide resiliency in a case of partial failure of a distributed database). Updates of a replicated object need to be synchronized across the object copies. In many cases the entire database is replicated.

Security[edit]

The following text needs to be harmonized with text in Database security.
Main article: Database security
Database security deals with all various aspects of protecting the database content, its owners, and its users. It ranges from protection from intentional unauthorized database uses to unintentional database accesses by unauthorized entities (e.g., a person or a computer program).

Database access control deals with controlling who (a person or a certain computer program) is allowed to access what information in the database. The information may comprise specific database objects (e.g., record types, specific records, data structures), certain computations over certain objects (e.g., query types, or specific queries), or utilizing specific access paths to the former (e.g., using specific indexes or other data structures to access information). Database access controls are set by special authorized (by the database owner) personnel that uses dedicated protected security DBMS interfaces.

This may be managed directly on an individual basis, or by the assignment of individuals and privileges to groups, or (in the most elaborate models) through the assignment of individuals and groups to roles which are then granted entitlements. Data security prevents unauthorized users from viewing or updating the database. Using passwords, users are allowed access to the entire database or subsets of it called "subschemas". For example, an employee database can contain all the data about an individual employee, but one group of users may be authorized to view only payroll data, while others are allowed access to only work history and medical data. If the DBMS provides a way to interactively enter and update the database, as well as interrogate it, this capability allows for managing personal databases.

Data security in general deals with protecting specific chunks of data, both physically (i.e., from corruption, or destruction, or removal; e.g., see physical security), or the interpretation of them, or parts of them to meaningful information (e.g., by looking at the strings of bits that they comprise, concluding specific valid credit-card numbers; e.g., see data encryption).

Change and access logging records who accessed which attributes, what was changed, and when it was changed. Logging services allow for a forensic database audit later by keeping a record of access occurrences and changes. Sometimes application-level code is used to record changes rather than leaving this to the database. Monitoring can be set up to attempt to detect security breaches.

Transactions and concurrency[edit]
Further information: Concurrency control
Database transactions can be used to introduce some level of fault tolerance and data integrity after recovery from a crash. A database transaction is a unit of work, typically encapsulating a number of operations over a database (e.g., reading a database object, writing, acquiring lock, etc.), an abstraction supported in database and also other systems. Each transaction has well defined boundaries in terms of which program/code executions are included in that transaction (determined by the transaction's programmer via special transaction commands).

The acronym ACID describes some ideal properties of a database transaction: Atomicity, Consistency, Isolation, and Durability.

Migration[edit]
See also section Database migration in article Data migration
A database built with one DBMS is not portable to another DBMS (i.e., the other DBMS cannot run it). However, in some situations it is desirable to move, migrate a database from one DBMS to another. The reasons are primarily economical (different DBMSs may have different total costs of ownership or TCOs), functional, and operational (different DBMSs may have different capabilities). The migration involves the database's transformation from one DBMS type to another. The transformation should maintain (if possible) the database related application (i.e., all related application programs) intact. Thus, the database's conceptual and external architectural levels should be maintained in the transformation. It may be desired that also some aspects of the architecture internal level are maintained. A complex or large database migration may be a complicated and costly (one-time) project by itself, which should be factored into the decision to migrate. This in spite of the fact that tools may exist to help migration between specific DBMSs. Typically a DBMS vendor provides tools to help importing databases from other popular DBMSs.

Building, maintaining, and tuning[edit]
Main article: Database tuning
After designing a database for an application, the next stage is building the database. Typically an appropriate general-purpose DBMS can be selected to be utilized for this purpose. A DBMS provides the needed user interfaces to be utilized by database administrators to define the needed application's data structures within the DBMS's respective data model. Other user interfaces are used to select needed DBMS parameters (like security related, storage allocation parameters, etc.).

When the database is ready (all its data structures and other needed components are defined) it is typically populated with initial application's data (database initialization, which is typically a distinct project; in many cases using specialized DBMS interfaces that support bulk insertion) before making it operational. In some cases the database becomes operational while empty of application data, and data is accumulated during its operation.

After the database is created, initialised and populated it needs to be maintained. Various database parameters may need changing and the database may need to be tuned (tuning) for better performance; application's data structures may be changed or added, new related application programs may be written to add to the application's functionality, etc.

Backup and restore[edit]
Main article: Backup
Sometimes it is desired to bring a database back to a previous state (for many reasons, e.g., cases when the database is found corrupted due to a software error, or if it has been updated with erroneous data). To achieve this a backup operation is done occasionally or continuously, where each desired database state (i.e., the values of its data and their embedding in database's data structures) is kept within dedicated backup files (many techniques exist to do this effectively). When this state is needed, i.e., when it is decided by a database administrator to bring the database back to this state (e.g., by specifying this state by a desired point in time when the database was in this state), these files are utilized to restore that state.

Other[edit]
Other DBMS features might include:

Database logs
Graphics component for producing graphs and charts, especially in a data warehouse system
Query optimizer – Performs query optimization on every query to choose for it the most efficient query plan (a partial order (tree) of operations) to be executed to compute the query result. May be specific to a particular storage engine.
Tools or hooks for database design, application programming, application program maintenance, database performance analysis and monitoring, database configuration monitoring, DBMS hardware configuration (a DBMS and related database may span computers, networks, and storage units) and related database mapping (especially for a distributed DBMS), storage allocation and database layout monitoring, storage migration, etc.
See also[edit]
Book icon	
Book: Databases
Main categories: Databases and Database management systems
Comparison of database tools
Comparison of object database management systems
Comparison of object-relational database management systems
Comparison of relational database management systems
Data hierarchy
Database theory
Database testing
Database-centric architecture
Question-focused dataset
References[edit]
Jump up ^ http://www.merriam-webster.com/dictionary/database
Jump up ^ Jeffrey Ullman 1997: First course in database systems, Prentice–Hall Inc., Simon & Schuster, Page 1, ISBN 0-13-861337-0.
Jump up ^ http://www.merriam-webster.com/dictionary/update
Jump up ^ http://www.merriam-webster.com/dictionary/retrieval
Jump up ^ http://www.merriam-webster.com/dictionary/administration
Jump up ^ Tsitchizris, D. C. and F. H. Lochovsky (1982). Data Models. Englewood-Cliffs, Prentice–Hall.
Jump up ^ Beynon-Davies P. (2004). Database Systems 3rd Edition. Palgrave, Basingstoke, UK. ISBN 1-4039-1601-2
Jump up ^ Raul F. Chong, Michael Dang, Dwaine R. Snow, Xiaomei Wang (3 July 2008). "Introduction to DB2". Retrieved 17 March 2013.. This article quotes a development time of 5 years involving 750 people for DB2 release 9 alone
Jump up ^ C. W. Bachmann (November 1973), "The Programmer as Navigator" (PDF), CACM (Turing Award Lecture 1973)
Jump up ^ Top DB index
Jump up ^ "database, n". OED Online. Oxford University Press. June 2013. Retrieved July 12, 2013.
Jump up ^ IBM Corporation. "IBM Information Management System (IMS) 13 Transaction and Database Servers delivers high performance and low total cost of ownership". Retrieved Feb 20, 2014.
Jump up ^ Codd, E.F. (1970)."A Relational Model of Data for Large Shared Data Banks". In: Communications of the ACM 13 (6): 377–387.
Jump up ^ William Hershey and Carol Easthope, "A set theoretic data structure and retrieval language", Spring Joint Computer Conference, May 1972 in ACM SIGIR Forum, Volume 7, Issue 4 (December 1972), pp. 45–55, DOI=10.1145/1095495.1095500
Jump up ^ Ken North, "Sets, Data Models and Data Independence", Dr. Dobb's, 10 March 2010
Jump up ^ Description of a set-theoretic data structure, D. L. Childs, 1968, Technical Report 3 of the CONCOMP (Research in Conversational Use of Computers) Project, University of Michigan, Ann Arbor, Michigan, USA
Jump up ^ Feasibility of a Set-Theoretic Data Structure : A General Structure Based on a Reconstituted Definition of Relation, D. L. Childs, 1968, Technical Report 6 of the CONCOMP (Research in Conversational Use of Computers) Project, University of Michigan, Ann Arbor, Michigan, USA
Jump up ^ MICRO Information Management System (Version 5.0) Reference Manual, M.A. Kahn, D.L. Rumelhart, and B.L. Bronson, October 1977, Institute of Labor and Industrial Relations (ILIR), University of Michigan and Wayne State University
Jump up ^ Interview with Wayne Ratliff. The FoxPro History. Retrieved on 2013-07-12.
Jump up ^ Development of an object-oriented DBMS; Portland, Oregon, United States; Pages: 472 – 482; 1986; ISBN 0-89791-204-7
Jump up ^ "Oracle Berkeley DB XML" (PDF). Retrieved 10 March 2015.
Jump up ^ "ACID Transactions, MarkLogic". Retrieved 10 March 2015.
Jump up ^ "Clusterpoint Database at a Glance". Retrieved 10 March 2015.
Jump up ^ "DB-Engines Ranking". January 2013. Retrieved 22 January 2013.
Jump up ^ Proctor, Seth (2013). "Exploring the Architecture of the NuoDB Database, Part 1". Retrieved 2013-07-12.
Jump up ^ "TeleCommunication Systems Signs up as a Reseller of TimesTen; Mobile Operators and Carriers Gain Real-Time Platform for Location-Based Services". Business Wire. 2002-06-24.
Jump up ^ Graves, Steve. "COTS Databases For Embedded Systems", Embedded Computing Design magazine, January 2007. Retrieved on August 13, 2008.
Jump up ^ Argumentation in Artificial Intelligence by Iyad Rahwan, Guillermo R. Simari
Jump up ^ "OWL DL Semantics". Retrieved 10 December 2010.
Jump up ^ itl.nist.gov (1993) Integration Definition for Information Modeling (IDEFIX). 21 December 1993.
^ Jump up to: a b Date 1990, pp. 31–32
Jump up ^ Chapple, Mike. "SQL Fundamentals". Databases. About.com. Retrieved 2009-01-28.
Jump up ^ "Structured Query Language (SQL)". International Business Machines. October 27, 2006. Retrieved 2007-06-10.
Jump up ^ Wagner, Michael (2010), "1. Auflage", SQL/XML:2006 – Evaluierung der Standardkonformität ausgewählter Datenbanksysteme, Diplomica Verlag, ISBN 3-8366-9609-6
Further reading[edit]
Ling Liu and Tamer M. Özsu (Eds.) (2009). "Encyclopedia of Database Systems, 4100 p. 60 illus. ISBN 978-0-387-49616-0.
Beynon-Davies, P. (2004). Database Systems. 3rd Edition. Palgrave, Houndmills, Basingstoke.
Connolly, Thomas and Carolyn Begg. Database Systems. New York: Harlow, 2002.
Date, C. J. (2003). An Introduction to Database Systems, Fifth Edition. Addison Wesley. ISBN 0-201-51381-1.
Gray, J. and Reuter, A. Transaction Processing: Concepts and Techniques, 1st edition, Morgan Kaufmann Publishers, 1992.
Kroenke, David M. and David J. Auer. Database Concepts. 3rd ed. New York: Prentice, 2007.
Raghu Ramakrishnan and Johannes Gehrke, Database Management Systems
Abraham Silberschatz, Henry F. Korth, S. Sudarshan, Database System Concepts
Discussion on database systems, [1]
Lightstone, S.; Teorey, T.; Nadeau, T. (2007). Physical Database Design: the database professional's guide to exploiting indexes, views, storage, and more. Morgan Kaufmann Press. ISBN 0-12-369389-6.
Teorey, T.; Lightstone, S. and Nadeau, T. Database Modeling & Design: Logical Design, 4th edition, Morgan Kaufmann Press, 2005. ISBN 0-12-685352-5
External links[edit]
Find more about
Database
at Wikipedia's sister projects
Search Wiktionary	Definitions from Wiktionary
Search Wikinews	News stories from Wikinews
Search Wikiquote	Quotations from Wikiquote
Search Wikisource	Source texts from Wikisource
Search Commons	Media from Commons
Search Wikibooks	Textbooks from Wikibooks
Search Wikiversity	Learning resources from Wikiversity
Database at DMOZ
DB File extension – informations about files with DB extension
[show] v t e
Database
[show] v t e
Database management systems
[show] v t e
Database models
[show] v t e
Data warehouse
Categories: Database management systemsDatabasesDatabase theory
Navigation menu
Create accountLog inArticleTalkReadEditView history

Main page
Contents
Featured content
Current events
Random article
Donate to Wikipedia
Wikipedia store
Interaction
Help
About Wikipedia
Community portal
Recent changes
Contact page
Tools
What links here
Related changes
Upload file
Special pages
Permanent link
Page information
Wikidata item
Cite this page
Print/export
Create a book
Download as PDF
Printable version
Languages
Afrikaans
العربية
Aragonés
Azərbaycanca
বাংলা
Беларуская
Беларуская (тарашкевіца)‎
Български
Boarisch
Bosanski
Brezhoneg
Català
Čeština
Cymraeg
Dansk
Deutsch
Eesti
Ελληνικά
Español
Esperanto
Euskara
فارسی
Français
Gaeilge
Galego
한국어
Հայերեն
हिन्दी
Hrvatski
Bahasa Indonesia
Interlingua
Íslenska
Italiano
עברית
Basa Jawa
ಕನ್ನಡ
ქართული
Қазақша
Kurdî
Кыргызча
Latina
Latviešu
Lietuvių
Magyar
Македонски
മലയാളം
مصرى
Bahasa Melayu
Mirandés
Монгол
မြန်မာဘာသာ
Nederlands
日本語
Norsk bokmål
Norsk nynorsk
Олык марий
Oʻzbekcha/ўзбекча
پښتو
Polski
Português
Română
Русский
Shqip
Sicilianu
සිංහල
Simple English
Slovenčina
Slovenščina
کوردی
Српски / srpski
Srpskohrvatski / српскохрватски
Suomi
Svenska
Tagalog
தமிழ்
తెలుగు
ไทย
Тоҷикӣ
Türkçe
Українська
اردو
Tiếng Việt
Walon
Winaray
中文
Edit links
This page was last modified on 14 April 2015, at 11:14.
Text is available under the Creative Commons Attribution-ShareAlike License; additional terms may apply. By using this site, you agree to the Terms of Use and Privacy Policy. Wikipedia® is a registered trademark of the Wikimedia Foundation, Inc., a non-profit organization.
Privacy policyAbout WikipediaDisclaimersContact WikipediaDevelopersMobile viewWikimedia Foundation Powered by MediaWiki